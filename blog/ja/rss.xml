<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>Armeria Blog - Japanese</title>
        <link>https://armeria.dev/blog/ja</link>
        <description></description>
        <lastBuildDate>Wed, 06 May 2020 11:00:00 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>en</language>
        <copyright>© 2015-2026, LY Corporation</copyright>
        <item>
            <title><![CDATA[Let’s play Reactive Streams with Armeria vol.2]]></title>
            <link>https://armeria.dev/blog/ja/2020/03/26/reactive-streams-armeria-2</link>
            <guid>https://armeria.dev/blog/ja/2020/03/26/reactive-streams-armeria-2</guid>
            <pubDate>Wed, 06 May 2020 11:00:00 GMT</pubDate>
            <description><![CDATA[こんにちは。LINE Plus でオープンソースソフトウェアの Armeria と Central Dogma を開発している UM IKHUN です。前回の記事では、Reactive Streams の概念を解説しました。今回の記事では、Reactive Streams をオープンソース非同期の HTTP/2、RPC、REST クライアント／サーバーライブラリーである Armeria で使用する方法について紹介したいと思います。]]></description>
            <content:encoded><![CDATA[<p>こんにちは。LINE Plus でオープンソースソフトウェアの Armeria と Central Dogma を開発している UM IKHUN です。<a class="" href="https://armeria.dev/blog/ja/2020/03/26/reactive-streams-armeria-1">前回の記事</a>では、Reactive Streams の概念を解説しました。今回の記事では、Reactive Streams をオープンソース非同期の HTTP/2、RPC、REST クライアント／サーバーライブラリーである Armeria で使用する方法について紹介したいと思います。</p>
<!-- -->
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="whats-armeria">What’s Armeria?<a href="https://armeria.dev/blog/ja/2020/03/26/reactive-streams-armeria-2#whats-armeria" class="hash-link" aria-label="Direct link to What’s Armeria?" title="Direct link to What’s Armeria?" translate="no">​</a></h2>
<p>Armeria は、Java 8 および Netty、Thrift、gRPC をベースにしたオープンソース非同期 HTTP/2、RPC、REST クライアント／サーバーライブラリーです。Armeria は、軽量（Lightweight）のマイクロサービスフレームワークですが、サポートする機能は、他のフルスタック（full stack）ウェブフレームワークと比較しても劣りません。</p>
<p>まず、Armeria で Reactive Streams を活用したサーバーを実現するために、基本的に知っておくべきことを説明します。</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="サポートするプロトコル">サポートするプロトコル<a href="https://armeria.dev/blog/ja/2020/03/26/reactive-streams-armeria-2#%E3%82%B5%E3%83%9D%E3%83%BC%E3%83%88%E3%81%99%E3%82%8B%E3%83%97%E3%83%AD%E3%83%88%E3%82%B3%E3%83%AB" class="hash-link" aria-label="Direct link to サポートするプロトコル" title="Direct link to サポートするプロトコル" translate="no">​</a></h3>
<p><img decoding="async" loading="lazy" src="https://armeria.dev/assets/images/reactive-streams-armeria-2-1-b8df78267813bd6db4a7146dc18e2f91.png" width="3030" height="1468" class="img_ev3q"></p>
<p>Armeria では、HTTP/1 と HTTP/2 を両方ともサポートしており、この 2 つのプロトコルは<a href="https://simple.wikipedia.org/wiki/Cleartext" target="_blank" rel="noopener noreferrer" class="">cleartext</a>と TLS（Transport Layer Security）暗号化通信をすべてサポートしています。HTTP/1 から HTTP/2 への互換性をサポートするためのプロトコルアップグレードについては、HTTP/2 の「connection preface」と HTTP/1 の「upgrade request」を両方ともサポートしています。</p>
<p>また、Armeria では gRPC と Thrift が、HTTP/1 と HTTP/2 の両方で動作します。これは Armeria ならではの特別な機能です。gRPC は HTTP/1 をサポートせず、既存の Thrift では HTTP/2 をサポートしません。しかし、Armeria ではすべてサポートしており、多様なビジネス環境で柔軟に使用できます。また、Linux 環境では、JNI（Java Native Interface）ベースのソケット IO と BoringSSL ベースの TLS により、一層スピーディに本番環境で使用できます。</p>
<p>では、サンプルコードを見ながら Armeria について 1 つずつ説明します。</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="サンプルコードで見る-armeria">サンプルコードで見る Armeria<a href="https://armeria.dev/blog/ja/2020/03/26/reactive-streams-armeria-2#%E3%82%B5%E3%83%B3%E3%83%97%E3%83%AB%E3%82%B3%E3%83%BC%E3%83%89%E3%81%A7%E8%A6%8B%E3%82%8B-armeria" class="hash-link" aria-label="Direct link to サンプルコードで見る Armeria" title="Direct link to サンプルコードで見る Armeria" translate="no">​</a></h3>
<p>Armeria は、ユーザーに優しい API です。コードが簡潔で使いやすくなっています。「Hello world」サーバーを実行したいときは、以下のように 5 行を作成するたけで済みます。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// Build your own server under 5 lines.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var server = Server.builder()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       .http(8080)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       .service("/", (ctx, req) -&gt; HttpResponse.of("Hello, World!"))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       .build();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">server.start();</span><br></span></code></pre></div></div>
<p>サーバーを簡単に実行できるというのは、マイクロサービス環境において各ビジネスコンポーネントを分離し、独立したサーバーとして管理するときにポイントになることです。</p>
<p>また、サーバーのアーキテクチャをシンプルにすることができます。HTTPS や HTTP/2 を使用するために別途の<a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/sidecar" target="_blank" rel="noopener noreferrer" class="">サイドカー</a>（sidecar）である Nginx や Apache Httpd のような静的 Web サーバーを実行する必要がありません。前述のように、Linux 環境では JNI ベースのソケット IO と BoringSSL をサポートするため、別途の性能低下を考慮する必要はありません。なお、JS や CSS、画像のような静的ファイルをホストする機能も提供しています（<a href="https://line.github.io/armeria/server-http-file.html" target="_blank" rel="noopener noreferrer" class="">参照</a>）。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">var server = Server.builder()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       .http(8080)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       .https(8443) // HTTPS support</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       .tlsSelfSigned()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       .service("/", (ctx, req) -&gt; HttpResponse.of("Hello, World!"))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       .build();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">server.start();</span><br></span></code></pre></div></div>
<p>ネットワークホップ（hop）を追加せずに済むため、障害点を減らすことができ、リソースを節約できるので効率よく通信できます。さらに、アーキテクチャがシンプルでモニタリングが簡単になり、サーバーを柔軟に拡張できます。</p>
<p>その他にも有効な機能が多くあります。その 1 つが、Armeria でビルトインで提供するアノテーション（annotation）です。アノテーションを利用すると、Armeria の機能をより簡単に使用できます。例えば、以下のように hello をプリフィックス（prefix）として、name を経路変数として設定し、ルーティングするコードを簡単に作成できます（<a href="https://line.github.io/armeria/server-annotated-service.html" target="_blank" rel="noopener noreferrer" class="">Armeria の公式文書</a>を参照すると、その他に多様なアノテーションをより詳しく見ることができます）。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">import com.linecorp.armeria.server.annotation.Get;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import com.linecorp.armeria.server.annotation.Param;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import com.linecorp.armeria.server.annotation.PathPrefix;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Use built-in annotations for mapping path and parameter injection</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@PathPrefix("/hello")</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class HelloService {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   @Get("/:name")</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   public String hello(@Param String name) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       return String.format("Hello, %s!", name);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>Armeria には、他の種類の RPC プロトコルを同時に扱える特別な機能もあります。1 つのサーバーで REST API と gRPC、Thrift をすべて提供できるため、ビジネスの要望やアーキテクチャの変化に柔軟に対応できます。また、単一ポートで提供しているので、リソースを効率よく使用してセキュリティの面で不要な露出を最低限に抑え、管理ポイントを削減できるメリットがあります。<a href="https://armeria.dev/blog/ja/2020/03/26/reactive-streams-armeria-2#footnotes" class="">[1]</a></p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">var server = Server.builder()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   .http(8080)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   .service("/hello/rest", (ctx, req) -&gt; HttpResponse.of("Hello, world!"))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   .service("/hello/thrift", THttpService.of(new ThriftHelloService()))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   .service("/hello/grpc", GrpcService.builder()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                      .addService(new GrpcHelloService())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                      .build())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   .build();</span><br></span></code></pre></div></div>
<p>エンタープライズソフトウェアの開発者は一般的に、認証やロギングなどをいかに効率よく処理できるかに関心を持って悩むと思います。Armeria では、<a href="https://en.wikipedia.org/wiki/Separation_of_concerns" target="_blank" rel="noopener noreferrer" class="">separation of concerns</a>と呼んでいるこのような部分を別途<a href="https://line.github.io/armeria/server-decorator.html" target="_blank" rel="noopener noreferrer" class="">decorator</a>で管理できる機能を提供しています。<a href="https://armeria.dev/blog/ja/2020/03/26/reactive-streams-armeria-2#footnotes" class="">[2]</a></p>
<p>また、標準で提供されていない decorator が必要であれば、直接簡単に実装し、特定経路やサービスにバインディングして使用することもできます。例えば、下図で実装した AuthService では、request に認証情報が含まれているときのみサービスを呼び出し、そうでなければ「401 unauthorized」エラーを発生させるようにしました。</p>
<p><img decoding="async" loading="lazy" src="https://armeria.dev/assets/images/reactive-streams-armeria-2-2-651dfe37d84cf70fa56b6314072fc869.png" width="3316" height="1652" class="img_ev3q"></p>
<p>次に、Armeria で Reactive Streams をどのようにサポートしているかを説明します。</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="armeria-内の-http2-ストーリム">Armeria 内の HTTP/2 ストーリム<a href="https://armeria.dev/blog/ja/2020/03/26/reactive-streams-armeria-2#armeria-%E5%86%85%E3%81%AE-http2-%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AA%E3%83%A0" class="hash-link" aria-label="Direct link to Armeria 内の HTTP/2 ストーリム" title="Direct link to Armeria 内の HTTP/2 ストーリム" translate="no">​</a></h3>
<p>ストリーム（stream）は流れている水のように、有機的に繋がり続ける必要があります。ある 1 か所だけ開いていて他のところは詰まっていると、すぐ溢れてしまいます。Armeria では、データの流れを有機的にコントロールするために、サーバー内では Reactive Streams のバックプレッシャーを利用してトラフィックをコントロールします。また、<a href="https://http2.github.io/http2-spec/#WINDOW_UPDATE" target="_blank" rel="noopener noreferrer" class="">WINDOW_UPDATE</a>を利用した<a href="https://tools.ietf.org/html/rfc7540#section-5.2" target="_blank" rel="noopener noreferrer" class="">HTTP/2 stream flow control</a>で、バックプレッシャーが配下のネットワークレイヤーで Armeria のサーバーと皆さんが実装したサービス、そしてデータのリポジトリまで有機的に繋げられるようにしました。</p>
<p><img decoding="async" loading="lazy" src="https://armeria.dev/assets/images/reactive-streams-armeria-2-3-19c9d7f507f0cc7efb072673431792ff.png" width="3336" height="1792" class="img_ev3q"></p>
<p>もし皆さんのサービスで使用しているサーバーを、今すぐ Armeria の Reactive サーバーに取り換えることができない事情があるなら、以下のように Armeria を Reactive プロキシサーバーとして活用することもできます（<a href="https://github.com/line/armeria-examples/tree/master/proxy-server" target="_blank" rel="noopener noreferrer" class="">参照</a>）。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// Use Armeria’s async &amp; reactive HTTP/2 client.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var client = HttpClient.of("h2c://backend");</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var server = Server.builder()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .http(8080)          // Forward all requests reactively</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .service("prefix:/", (ctx, req) -&gt; client.execute(req))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .build();</span><br></span></code></pre></div></div>
<p>Armeria プロキシサーバーを前に配置すると、皆さんのサーバーを厳しい外部のインターネットから安全に保護できます。</p>
<p><img decoding="async" loading="lazy" src="https://armeria.dev/assets/images/reactive-streams-armeria-2-4-d1176606f39d7cc2951b0a21a74b80c6.png" width="2310" height="716" class="img_ev3q"></p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="reactive-streams-と-armeria-の統合">Reactive Streams と Armeria の統合<a href="https://armeria.dev/blog/ja/2020/03/26/reactive-streams-armeria-2#reactive-streams-%E3%81%A8-armeria-%E3%81%AE%E7%B5%B1%E5%90%88" class="hash-link" aria-label="Direct link to Reactive Streams と Armeria の統合" title="Direct link to Reactive Streams と Armeria の統合" translate="no">​</a></h2>
<p>Armeria で直接 Reactive Streams をサポートするサーバーを作ると、より多様な機能を使用できます。Armeria で Reactive Streams を活用する方法とビルトイン publisher についてより詳しく説明します。</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="armeria-http-レスポンスの-publisher">Armeria HTTP レスポンスの Publisher<a href="https://armeria.dev/blog/ja/2020/03/26/reactive-streams-armeria-2#armeria-http-%E3%83%AC%E3%82%B9%E3%83%9D%E3%83%B3%E3%82%B9%E3%81%AE-publisher" class="hash-link" aria-label="Direct link to Armeria HTTP レスポンスの Publisher" title="Direct link to Armeria HTTP レスポンスの Publisher" translate="no">​</a></h3>
<p>Armeria のレスポンスは、ヘッダーを表現する<a href="https://line.github.io/armeria/apidocs/com/linecorp/armeria/common/HttpHeaders.html" target="_blank" rel="noopener noreferrer" class="">HttpHeaders</a>とデータを表現する<a href="https://line.github.io/armeria/apidocs/com/linecorp/armeria/common/HttpData.html" target="_blank" rel="noopener noreferrer" class="">HttpData</a>で構成されています。ここでは、RxJava の<a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html" target="_blank" rel="noopener noreferrer" class="">Observable</a>を Armeria の<a href="https://line.github.io/armeria/apidocs/com/linecorp/armeria/common/HttpResponse.html" target="_blank" rel="noopener noreferrer" class="">HttpResponse</a>に取り換える過程を、ステップごとに見てみましょう。</p>
<p>データの準備が終わったら、まず Observable の map 演算子を利用して dataStream を HttpData でラップします。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 1. Fetch data from Reactive Streams Publisher</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Observable&lt;String&gt; dataStream = Observable.just("a", "b", "c", "d", "e");</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 2. Convert string to Armeria HttpData</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Observable&lt;HttpData&gt; httpDataStream = dataStream.map(HttpData::ofUtf8);</span><br></span></code></pre></div></div>
<p>どのようにレスポンスするかを決めてレスポンスヘッダーを準備した後、concat 演算子を利用して、上記で準備した httpDataStream と合わせると、HttpHeaders から HttpData に繋がる 1 つのストリームが完成します。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 3. Prepare response headers</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ResponseHeaders httpHeaders = ResponseHeaders.of(HttpStatus.OK);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 4. Concat http header and body stream</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Observable&lt;HttpObject&gt; responseStream = Observable.concat(Observable.just(httpHeaders), httpDataStream);</span><br></span></code></pre></div></div>
<p>完成したストリームを Observable の toFlowable 関数を利用して Reactive Streams の<a href="https://www.baeldung.com/rxjava-2-flowable" target="_blank" rel="noopener noreferrer" class="">Flowable</a>に変換した後、最終的に Armeria の HttpResponse でラップすれば終わりです。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 5. Convert Observable to Armeria Response Stream</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">HttpResponse response = HttpResponse.of(responseStream.toFlowable(BackpressureStrategy.BUFFER));</span><br></span></code></pre></div></div>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="armeria-のビルトイン-publisher">Armeria のビルトイン Publisher<a href="https://armeria.dev/blog/ja/2020/03/26/reactive-streams-armeria-2#armeria-%E3%81%AE%E3%83%93%E3%83%AB%E3%83%88%E3%82%A4%E3%83%B3-publisher" class="hash-link" aria-label="Direct link to Armeria のビルトイン Publisher" title="Direct link to Armeria のビルトイン Publisher" translate="no">​</a></h3>
<p>上記の過程がやや複雑に、あるいは長くて退屈に感じられたかもしれません。そこで、Armeria では Web でストリームデータを送信する方法の標準である<a href="https://tools.ietf.org/html/rfc7464" target="_blank" rel="noopener noreferrer" class="">JSON Text Sequences（RFC 7464）</a>と HTML5 の規格である<a href="https://en.wikipedia.org/wiki/Server-sent_events" target="_blank" rel="noopener noreferrer" class="">Server-sent events</a>に対するビルトイン Publisher を提供します。この publisher を利用すると、Reactive Streams をより便利に Web で送信できます。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// Fetch data from Reactive Streams Publisher</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Publisher&lt;String&gt; dataStream = Flux.just("a", "b", "c", "d", "e");</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Convert Publisher to JSON Text Sequences with Armeria HttpResponse</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// with "application/json-seq" MIME type</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">HttpResponse httpResponse = JsonTextSequences.fromPublisher(dataStream);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Convert Publisher to Server-sent Events with Armeria HttpResponse</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// with "text/event-stream" MIME type</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">HttpResponse httpResponse = ServerSentEvents</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .fromPublisher(dataStream, SeverSentEvent::ofData);</span><br></span></code></pre></div></div>
<p>また、ビルトイン publisher をより簡単に使用できるように RxJava 統合をサポートしています。アノテーションのサービスに@ProducesJsonSequences アノテーションを追加し、Observable をそのまま返すと、Armeria で当該プロトコルで自動的に変換します。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">import io.reactivex.Observable;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import com.linecorp.armeria.server.annotation.ProducesJsonSequences;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class RxJavaService {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Get("/json-streaming")</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      // Generate JSON Text Sequences</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @ProducesJsonSequences</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Observable&lt;String&gt; json() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          // Just return RxJava Observable!</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return Observable.just("a", "b", "c");</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre></div></div>
<p>以下のように「JsonTextSequences」でエンコードすると、JSON 文字列の最初と最後のところにレコード分離文字（separator）とラインフィード（line feed）が追加されます。また、現在のプロトコルによって HTTP/1 や HTTP/2 に送信される際、違う動作になるべきです。Armeria では現在繋がっているプロトコルに従って、適したタイプのデータを送信します。HTTP/2 の場合は、<a href="https://http2.github.io/http2-spec/#DATA" target="_blank" rel="noopener noreferrer" class="">Data frame</a>の中に JSON データを分けて送り、HTTP/1 の場合は<a href="https://en.wikipedia.org/wiki/Chunked_transfer_encoding" target="_blank" rel="noopener noreferrer" class="">chunked transfer encoding</a>を利用して分けて送ります。</p>
<p><img decoding="async" loading="lazy" src="https://armeria.dev/assets/images/reactive-streams-armeria-2-5-b047c88a956d6aea2e8163ea08fd3590.png" width="3278" height="1818" class="img_ev3q"></p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="spring-webflux-の統合">Spring WebFlux の統合<a href="https://armeria.dev/blog/ja/2020/03/26/reactive-streams-armeria-2#spring-webflux-%E3%81%AE%E7%B5%B1%E5%90%88" class="hash-link" aria-label="Direct link to Spring WebFlux の統合" title="Direct link to Spring WebFlux の統合" translate="no">​</a></h2>
<p>Armeria は、さまざまなライブラリーおよびフレームワークとの連携をサポートします。Reactive Streams を使用するために、すでに<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html" target="_blank" rel="noopener noreferrer" class="">Spring WebFlux</a>を使用している場合は、コードを別途修正せずに「armeria-spring-boot-webflux-starter」を依存性に追加（<a href="http://wiki.linecorp.com/" target="_blank" rel="noopener noreferrer" class="">参照</a>）するだけで、Armeria へのマイグレーションを完了できます。このような方法で、WebFlux のネットワークレイヤーである<a href="https://github.com/reactor/reactor-netty" target="_blank" rel="noopener noreferrer" class="">Reactor-Netty</a>を Armeria の Reactive エンジンに取り換えることができます。</p>
<p><img decoding="async" loading="lazy" src="https://armeria.dev/assets/images/reactive-streams-armeria-2-6-0408b3405e56818eebd1d7b8471bbc75.png" width="3120" height="1346" class="img_ev3q"></p>
<p>単にエンジンを取り換えるだけなら「ただ WebFlux だけ使用すればいいんじゃないか」という疑問が湧くかもしれません。エンジンを取り換えることに、果たしてどのようなメリットがあるのでしょう。</p>
<p>エンジンを取り換えると、<a href="https://line.github.io/armeria/apidocs/com/linecorp/armeria/spring/ArmeriaServerConfigurator.html" target="_blank" rel="noopener noreferrer" class="">ArmeriaServerConfigurator</a>により Spring で Armeria の機能を追加できるため、既存の Spring ではサポートしない Armeria ならではの機能を活用できます。例えば、以下のように REST API で構成される既存の Spring Webflux サーバーに gRPC や Thrift 機能を追加し、従来と同じく単一ポートでサービスできます。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">@Configuration</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class ArmeriaConfiguration {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   // Configure the server by providing an ArmeriaServerConfigurator bean.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   @Bean</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   public ArmeriaServerConfigurator armeriaServerConfigurator() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       // Customize the server using the given ServerBuilder. For example:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       return builder -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           // Add DocService that enables you to send gRPC and Thrift requests from web browser.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           builder.serviceUnder("/docs", new DocService());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           // Log every message which the server receives and responds.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           builder.decorator(LoggingService.newDecorator());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           // Write access log after completing a request.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           builder.accessLogWriter(AccessLogWriter.combined(), false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           // You can also bind asynchronous RPC services such as Thrift and gRPC:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           builder.service(THttpService.of(…));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           builder.service(GrpcService.builder()…build());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>なお、他にも前述で説明したように decorator 機能を活用し、さらに機能が豊富なサービスを構築できます。</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="grpc-のストリームサポート">gRPC のストリームサポート<a href="https://armeria.dev/blog/ja/2020/03/26/reactive-streams-armeria-2#grpc-%E3%81%AE%E3%82%B9%E3%83%88%E3%83%AA%E3%83%BC%E3%83%A0%E3%82%B5%E3%83%9D%E3%83%BC%E3%83%88" class="hash-link" aria-label="Direct link to gRPC のストリームサポート" title="Direct link to gRPC のストリームサポート" translate="no">​</a></h2>
<p>gRPC は、<a href="https://grpc.github.io/grpc-java/javadoc/io/grpc/stub/StreamObserver.html" target="_blank" rel="noopener noreferrer" class="">StreamObserver</a>を利用してストリームをサポートします（<a href="https://grpc.io/docs/tutorials/basic/java/#server-side-streaming-rpc" target="_blank" rel="noopener noreferrer" class="">参照</a>）。Reactive Streams で発行（publish）されるデータを<a href="https://grpc.github.io/grpc-java/javadoc/io/grpc/stub/StreamObserver.html" target="_blank" rel="noopener noreferrer" class="">S</a><a href="https://grpc.github.io/grpc-java/javadoc/io/grpc/stub/StreamObserver.html" target="_blank" rel="noopener noreferrer" class="">t</a><a href="https://grpc.github.io/grpc-java/javadoc/io/grpc/stub/StreamObserver.html" target="_blank" rel="noopener noreferrer" class="">reamObserver</a>で簡単に送信できます。サンプルで見てみます。</p>
<p>まず以下のように protobuf を利用してデータをどのようにやり取りするか、インターフェースを定義します。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">syntax = "proto3";</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">package users;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">option java_package = "users";</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">service UserService {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Returns all user information</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  rpc getAllUsers(UserRequest) returns (stream User) {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Push to stream of users</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  rpc pushToUsers(stream User) returns (Result) {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>会員全体にメールまたはプッシュメッセージを送信したいときは、まずすべてのユーザー情報を取得する必要があります。もし会員数があまりにも多い場合、データを一度に送信することは難しいかもしれません。そのような場合は、以下のような方法で大量のユーザー情報を返すストリームサーバーを gRPC で構築することができます。</p>
<ol>
<li class="">ProjectReactor の Flux を Publisher として使用し、リポジトリからストリームでデータを取得します。</li>
<li class="">データを、gRPC の StreamObservser に変換して外部へ送信します。</li>
</ol>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// Implement interfaces generated by gRPC</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public final class UserServiceImpl extends UserServiceImplBase {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void getAllUsers(UserRequest request, StreamObserver&lt;User&gt; responseObserver) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final Flux&lt;User&gt; userPublisher = userRepo.findAll();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        publisher.subscribe(responseObserver::onNext,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            responseObserver::onError,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            responseObserver::onCompleted);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>StreamObserver にも Reactive Streams と同様に onNext、onError、onCompleted 関数が存在するため、それぞれの API に委譲するだけで終わります。</p>
<p>今度は受信する側で、すべてのユーザー情報をストリームで受けることを考えてみましょう。ストリームで受けるには、<a href="https://www.reactive-streams.org/reactive-streams-1.0.0-javadoc/org/reactivestreams/Processor.html" target="_blank" rel="noopener noreferrer" class="">Processor</a>を活用します。Processor は別途の API を持っておらず、Subscriber と Publisher、この 2 つのインターフェースを継承しているだけです。Processor は、データを購読し、購読したデータを再度発行する際に役に立ちます。StreamObserver の onNext で入ってきた新しいユーザー情報を Processor の onNext 関数で送信でき、それを再度購読して必要な作業を追加で行うことができます。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">@Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public StreamObserver&lt;User&gt; pushToUsers(StreamObserver&lt;Result&gt; responseObserver) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Processor&lt;User, User&gt; processor = EmitterProcessor.create();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Publisher&lt;User&gt; publisher = processor;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Subscriber&lt;User&gt; subscriber = processor;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Push one-by-one by subscribing publisher</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return new StreamObserver&lt;User&gt;() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // subscribe user data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Override public void onNext(User user) { processor.onNext(user); }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Override public void onError(Throwable throwable) { processor.onError(throwable); }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Override public void onCompleted() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            responseObserver.onNext(Result.newBuilder().setStatus(200).build());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            responseObserver.onCompleted();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>作成した gRPC コードを Armeria で実行してみます。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">import com.linecorp.armeria.server.Server;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import com.linecorp.armeria.server.grpc.GrpcService;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Add your grpc service to Armeria GrpcService</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var grpcService = GrpcService.builder()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                             .addService(new UserServiceImpl())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                             .build();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var server = Server.builder()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   .http(8080)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   .serviceUnder("/grpc", grpcService)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   .serviceUnder("/docs", new DocService())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   .build();</span><br></span></code></pre></div></div>
<p>このようにして作ったストリームサーバーを利用し、小さいメモリーでも大量のデータをストリームで処理することができます。</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="マイクロサービスのための-armeria-の機能">マイクロサービスのための Armeria の機能<a href="https://armeria.dev/blog/ja/2020/03/26/reactive-streams-armeria-2#%E3%83%9E%E3%82%A4%E3%82%AF%E3%83%AD%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AE-armeria-%E3%81%AE%E6%A9%9F%E8%83%BD" class="hash-link" aria-label="Direct link to マイクロサービスのための Armeria の機能" title="Direct link to マイクロサービスのための Armeria の機能" translate="no">​</a></h2>
<p>Armeria により Reactive Streams を活用すると、大量のデータとトラフィックを柔軟に処理できます。また、RPC でマイクロサービス間の通信も簡単に処理できます。</p>
<p>他にも以下のように、マイクロサービスに必要なさまざまな機能を提供しています。</p>
<ul>
<li class="">クラウド環境でサーバーの位置を把握するため、Kubernetes タイプの DNS（Domain Name System）と ZooKeeper を活用したサービス検索（discovery）を提供（<a href="https://line.github.io/armeria/advanced-zookeeper.html" target="_blank" rel="noopener noreferrer" class="">参照</a>）しています。</li>
<li class="">検索されたサービスは、クライアント側のロードバランシングで直接負荷を分散してサーバーと通信します。それにより障害点を減らすことができます。</li>
<li class=""><a href="https://www.nginx.com/resources/glossary/layer-7-load-balancing/" target="_blank" rel="noopener noreferrer" class="">L7</a>ではないクライアントが、直接サーバーの状態をチェックできます。</li>
<li class="">ログを確認する際、分散されたサーバーにアクセスせずに確認できるように、Kafka でアクセスログを送信します。</li>
<li class="">Micrometer を活用して必要な数値を設定・収集し、Prometheus や Netflix の Atlas のようなアプリケーションモニタリングツールで送信できます。<br>
<img decoding="async" loading="lazy" src="https://armeria.dev/assets/images/reactive-streams-armeria-2-7-da8c2428f8f86f6212efef177ca57d88.png" width="3076" height="1428" class="img_ev3q"></li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="おわりに">おわりに<a href="https://armeria.dev/blog/ja/2020/03/26/reactive-streams-armeria-2#%E3%81%8A%E3%82%8F%E3%82%8A%E3%81%AB" class="hash-link" aria-label="Direct link to おわりに" title="Direct link to おわりに" translate="no">​</a></h2>
<p>2 回に渡って Reactive Streams と Armeria について紹介しました。一緒に見てみたように Armeria を利用すると、Reactive Streams と高性能、非同期、RPC、HTTP/2 をサポートするうえ障害に柔軟な、より安全なサーバーを構築できます。</p>
<p>Armeria では、記事で触れた機能以外にもさらに多くの機能を提供しています。それに関しては、Armeria の<a href="https://line.github.io/armeria/index.html" target="_blank" rel="noopener noreferrer" class="">公式ホームページ</a>と以下のリンクをご参照ください。</p>
<ul>
<li class="">GitHub: <a href="https://github.com/line/armeria" target="_blank" rel="noopener noreferrer" class="">line/armeria</a></li>
<li class="">Twitter: <a href="https://twitter.com/armeria_project" target="_blank" rel="noopener noreferrer" class="">@armeria_project</a></li>
<li class="">Chat: <a href="https://armeria.dev/s/discord" target="_blank" rel="noopener noreferrer" class="">Discord</a></li>
<li class=""><a href="https://line.github.io/armeria/apidocs/index.html#://" target="_blank" rel="noopener noreferrer" class="">API documentation</a></li>
<li class="">Armeria examples: <a href="https://github.com/line/armeria-examples" target="_blank" rel="noopener noreferrer" class="">line/armeria-examples</a></li>
</ul>
<hr>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="footnotes">Footnotes<a href="https://armeria.dev/blog/ja/2020/03/26/reactive-streams-armeria-2#footnotes" class="hash-link" aria-label="Direct link to Footnotes" title="Direct link to Footnotes" translate="no">​</a></h4>
<ol>
<li class="">
<p><a href="https://line.github.io/armeria/server-grpc.html" target="_blank" rel="noopener noreferrer" class="">gRPC サーバーを Armeria で起動する方法</a>と<a href="https://line.github.io/armeria/server-thrift.html" target="_blank" rel="noopener noreferrer" class="">Thrift サーバーを Armeria で起動する方法</a>をご参照ください。</p>
</li>
<li class="">
<p>Armeria で標準提供するさまざまな decorator は、公式文書と以下の Javadoc でご確認できます。</p>
</li>
</ol>
<ul>
<li class=""><a href="https://line.github.io/armeria/apidocs/com/linecorp/armeria/server/SimpleDecoratingHttpService.html" target="_blank" rel="noopener noreferrer" class="">SimpleDecoratingHttpService</a>と<a href="https://line.github.io/armeria/apidocs/com/linecorp/armeria/client/SimpleDecoratingClient.html" target="_blank" rel="noopener noreferrer" class="">SimpleDecoratingClient</a>の Direct Known Subsclasses 項目</li>
</ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Let’s play Reactive Streams with Armeria vol.1]]></title>
            <link>https://armeria.dev/blog/ja/2020/03/26/reactive-streams-armeria-1</link>
            <guid>https://armeria.dev/blog/ja/2020/03/26/reactive-streams-armeria-1</guid>
            <pubDate>Wed, 06 May 2020 10:00:00 GMT</pubDate>
            <description><![CDATA[Reactive Streamsとは？]]></description>
            <content:encoded><![CDATA[<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="reactive-streamsとは">Reactive Streamsとは？<a href="https://armeria.dev/blog/ja/2020/03/26/reactive-streams-armeria-1#reactive-streams%E3%81%A8%E3%81%AF" class="hash-link" aria-label="Direct link to Reactive Streamsとは？" title="Direct link to Reactive Streamsとは？" translate="no">​</a></h2>
<p>LINE PlusでオープンソースソフトウェアのArmeriaとCentral Dogmaを開発しているUM IKHUNです。私はReactive Streamsの概念と、Reactive Streamsをオープンソースの非同期HTTP/2、RPC、RESTクライアント／サーバーライブラリーであるArmeriaで使用する方法について紹介したいと思います。今回の記事では、まずReactive Streamsの概念について解説します。</p>
<p>Reactive Streamsは、公式ホームページである<a href="http://reactive-streams.org/" target="_blank" rel="noopener noreferrer" class="">reactive-streams.org</a>で以下のように定義しています。</p>
<blockquote>
<p>Reactive Streams is a standard for asynchronous data processing in a streaming fashion with non-blocking back pressure.</p>
</blockquote>
<p>ホームページでは、Reactive Streamは、ノンブロッキングバックプレッシャー（Non-blocking back pressure）を利用した非同期データ処理の標準であると言っています。では、「ストリーム処理」、「非同期（asynchronous）方式」、「バックプレッシャー」そして「標準」といったそれぞれの言葉が意味することをより詳しく見てみます。</p>
<!-- -->
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="ストリーム処理">ストリーム処理<a href="https://armeria.dev/blog/ja/2020/03/26/reactive-streams-armeria-1#%E3%82%B9%E3%83%88%E3%83%AA%E3%83%BC%E3%83%A0%E5%87%A6%E7%90%86" class="hash-link" aria-label="Direct link to ストリーム処理" title="Direct link to ストリーム処理" translate="no">​</a></h3>
<p>下図は通常のデータ処理とストリーム処理を比較したものです。</p>
<p><img decoding="async" loading="lazy" src="https://armeria.dev/assets/images/reactive-streams-armeria-1-1-2f25791f2d6557baebc7d095eda17c7d.png" width="3342" height="1882" class="img_ev3q"></p>
<p>左の通常のデータ処理では、データ処理のリクエストが来ると、ペイロード（payload）をすべてアプリケーションのメモリーに保存してから次の処理を行います。追加で必要なデータもリポジトリから取得して、メモリーにロードします。この方式の問題点は、送信されたデータはもちろん、リポジトリから取得したデータまですべてのデータがアプリケーションのメモリーにロードされてから、応答メッセージを作成できるということです。もし必要なデータのサイズがメモリーのサイズより大きければ、「out of memory」というエラーが発生します。また、サービスを運用してみると、個別のリクエストが「out of memory」を発生させなくても、一瞬多くのリクエストが殺到してしまい、多量のGC（Garbage Collection）が発生してサーバーが正常に応答できない場合が多々発生します。</p>
<p>一方、大量のデータを処理するアプリケーションにストリーム処理を適用すると、サイズが小さいシステムメモリーでも大量のデータを処理できます。入力されたデータに対するパイプライン（上の図全体をパイプラインと表現しています）を作ってデータが入ってくるがままに購読（subscribe）し、処理した後、発行（publish）までノンストップで処理できます。このようにすると、サーバーは大量のデータも柔軟に処理できます。</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="非同期方式">非同期方式<a href="https://armeria.dev/blog/ja/2020/03/26/reactive-streams-armeria-1#%E9%9D%9E%E5%90%8C%E6%9C%9F%E6%96%B9%E5%BC%8F" class="hash-link" aria-label="Direct link to 非同期方式" title="Direct link to 非同期方式" translate="no">​</a></h3>
<p>非同期方式については、同期（synchronous）方式と比較しながら説明します。下図は、同期方式と非同期方式の処理過程を示したものです。</p>
<p><img decoding="async" loading="lazy" src="https://armeria.dev/assets/images/reactive-streams-armeria-1-2-f4e515c6966123761077255924895887.png" width="3344" height="1876" class="img_ev3q"></p>
<p>同期方式では、クライアントがサーバーにリクエストを送ると、応答を受けるまでブロッキング（blocking）されます。ブロッキングされるということは、現在のスレッド（thread）は、他のタスクを処理せずに、現在のタスクが終わるのを待っていることを意味します。そのため、2つのリクエストをAとBのサーバーに送るとしたら、Aの応答が終わって、ようやくBにリクエストを送ることができます。しかし、非同期方式では、現在のスレッドがブロッキングされないため、他のタスクを続けることができます。Aにリクエストを送った後に他のタスクを処理することや、あるいはBに他のリクエストを送ることもできます。同期方式と比較して非同期方式のメリットをまとめると以下のようになります。</p>
<ul>
<li class="">速いスピード - ２つのリクエストを同時に送るため、応答スピードがより早くなります。</li>
<li class="">少ないリソースを使用 - 現在のスレッドがブロッキングされずに他のタスクを処理できるため、より少ない数のスレッドでより多くのリクエストを処理できます。</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="バックプレッシャー">バックプレッシャー<a href="https://armeria.dev/blog/ja/2020/03/26/reactive-streams-armeria-1#%E3%83%90%E3%83%83%E3%82%AF%E3%83%97%E3%83%AC%E3%83%83%E3%82%B7%E3%83%A3%E3%83%BC" class="hash-link" aria-label="Direct link to バックプレッシャー" title="Direct link to バックプレッシャー" translate="no">​</a></h3>
<p>バックプレッシャーについて説明するために、<a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="noopener noreferrer" class="">RxJava</a>で有名になったObserverパターン（<a href="http://reactivex.io/documentation/observable.html" target="_blank" rel="noopener noreferrer" class="">observer patten</a>）とプッシュ（push）型、そしてプル（pull）型について説明します。</p>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="プッシュ型">プッシュ型<a href="https://armeria.dev/blog/ja/2020/03/26/reactive-streams-armeria-1#%E3%83%97%E3%83%83%E3%82%B7%E3%83%A5%E5%9E%8B" class="hash-link" aria-label="Direct link to プッシュ型" title="Direct link to プッシュ型" translate="no">​</a></h4>
<p><img decoding="async" loading="lazy" src="https://armeria.dev/assets/images/reactive-streams-armeria-1-3-f90a82d7c69e036ae62f224a2fff1c57.png" width="2040" height="1002" class="img_ev3q"></p>
<p>Observerパターンでは、発行者（publisher）が購読者（subscriber）にプッシュする形でデータが送信されます。発行者は購読者の状態を考慮せず、データを送信するだけです。仮に、発行者が１秒に100個のメッセージを送るのに、購読者は1秒に10個しか処理できないとしたら、どうすればいいでしょうか。購読者が処理できないメッセージ（待機中のイベント）を、キュー（queue）を利用して保存するしかありません。</p>
<p><img decoding="async" loading="lazy" src="https://armeria.dev/assets/images/reactive-streams-armeria-1-4-e144d9d9e9c035b0f776f6d81465a871.png" width="2656" height="1158" class="img_ev3q"></p>
<p>サーバーが使えるメモリーは限られています。仮に、1秒に100個のメモリーを続けてプッシュするとしたら、バッファは一瞬で使い切られるはずです。バッファを使い切ってオーバーフロー（overflow）が発生すると、どうなるでしょうか。固定長バッファと可変長バッファで、発生する事象が異なります。</p>
<ul>
<li class="">固定長バッファ：オーバーフロー（overflow）が発生すると、新規で受信したメッセージを拒否します。拒否されたメッセージは再びリクエストすることになりますが、再リクエストの過程でネットワークとCPU演算のコストが追加で発生します。<br>
<img decoding="async" loading="lazy" src="https://armeria.dev/assets/images/reactive-streams-armeria-1-5-5271512498a52243394d8a9ba2e15c3a.png" width="2684" height="1358" class="img_ev3q"></li>
<li class="">可変長バッファ：オーバーフロー（overflow）が発生すると、イベントを保存するときに「out of memory」エラーが発生し、サーバークラッシュ（crash）が発生します。「誰がそのように実装するんだ？」と思いがちですが、Javaで多く使用されるListが可変長データ構造型です。例えば、SQLで多量のデータを問い合わせすると、DBMSは発行者になり、皆さんのサーバーが購読者になります。そうなると、Listデーター構造型にデータを全部入れ込もうとして多量のGCが発生するため、サーバーが正常に応答できない状態になることがあります。<br>
<img decoding="async" loading="lazy" src="https://armeria.dev/assets/images/reactive-streams-armeria-1-6-93355b83286fefdd6b5dac13f0e5957a.png" width="2694" height="1328" class="img_ev3q"></li>
</ul>
<p>この問題をどう解決できるでしょうか。発行者がデータを送信する際、購読者に必要なデータだけを送ることができれば、解決できるのではないでしょうか。これが、バックプレッシャーの基本原理です。</p>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="プル型">プル型<a href="https://armeria.dev/blog/ja/2020/03/26/reactive-streams-armeria-1#%E3%83%97%E3%83%AB%E5%9E%8B" class="hash-link" aria-label="Direct link to プル型" title="Direct link to プル型" translate="no">​</a></h4>
<p><img decoding="async" loading="lazy" src="https://armeria.dev/assets/images/reactive-streams-armeria-1-7-23bbdc8de88d80bfb99c448b495dcbcd.png" width="2558" height="1082" class="img_ev3q"></p>
<p>プル型では、購読者が10個を処理できるとしたら、発行者に10個だけリクエストします。発行者はリクエストされた分だけ送信し、購読者はそれ以上「out of memory」エラーを心配しなくて済みます。</p>
<p>ここでより柔軟に、購読者がすでに8つのタスクを処理していたら、追加で2つだけさらにリクエストし、購読者が現在処理できる範囲内でメッセージを受け取るようにします。プル型では、このようにして送信されるすべてのデータのサイズを購読者が決めます。このようなダイナミックプル型のデータリクエストにより、購読者が受け入れられるだけのデータをリクエストする方式がバックプレッシャーです。</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="標準">標準<a href="https://armeria.dev/blog/ja/2020/03/26/reactive-streams-armeria-1#%E6%A8%99%E6%BA%96" class="hash-link" aria-label="Direct link to 標準" title="Direct link to 標準" translate="no">​</a></h3>
<p>Reactive Streamsは、標準化されたAPIです。なぜ標準化が必要で、どのような過程で標準になったかを説明します。</p>
<p>Reactive Streamsは、2013年にNetflixとPivotal、Lightbendのエンジニアらが初めて開発を手掛けました。NetflixはRxJavaを、PivotalはWebFluxを、そしてLightbendは分散処理アクター（actor）モデルを実現したAkkaを開発した会社です。これらの会社はすべて、ストリームAPIが必要な会社でした。しかし、ストリームはお互い有機的に絡まって流れてこそ初めて意味があります。データをストリームで流し続けるためには、別々の会社が共通の仕様を策定して、実装する必要があります。そのため標準化が必要でした。</p>
<p>Reactive Streamsでは、2015年4月にJVMで使用するための<a href="https://www.reactive-streams.org/announce-1.0.0" target="_blank" rel="noopener noreferrer" class="">Reactive Streams 1.0.0</a>をリリースしました。そして、2017年9月にReactive StreamsのAPIと仕様、プル（pull）型の使用原則をそのままポーティングして、<a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Flow.html" target="_blank" rel="noopener noreferrer" class="">Flow API</a>という名前で、java.util.concurrentパッケージの下に含めたJava 9がリリースされました。これは、コミュニティや一部の企業でリードして開発していたReactive Streamsが、Javaの公式機能になったことを意味します。さらに3か月後、Reactive StreamsでFlowと相互変換が可能なアダプターをリリースし、Flow APIで既存のライブラリーを使用できるようになりました。</p>
<p><img decoding="async" loading="lazy" src="https://armeria.dev/assets/images/reactive-streams-armeria-1-8-d9ff99c821b42b8a7ed40882fcd3f69e.png" width="3318" height="1846" class="img_ev3q"></p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="reactive-streams-api">Reactive Streams API<a href="https://armeria.dev/blog/ja/2020/03/26/reactive-streams-armeria-1#reactive-streams-api" class="hash-link" aria-label="Direct link to Reactive Streams API" title="Direct link to Reactive Streams API" translate="no">​</a></h2>
<p>Reactive Streamsは、言葉だけを見ると複雑に見えますが、実際に中を見ると非常に簡単なAPIの組み合わせで構成されていることがわかります。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public interface Publisher&lt;T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   public void subscribe(Subscriber&lt;? super T&gt; s);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public interface Subscriber&lt;T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   public void onSubscribe(Subscription s);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   public void onNext(T t);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   public void onError(Throwable t);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   public void onComplete();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public interface Subscription {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   public void request(long n);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   public void cancel();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<ul>
<li class="">PublisherのAPIは、Subscriberの購読を受けるためのsubscribeが1つあるだけです。</li>
<li class="">SubscriberのAPIは、受け取ったデータを処理するためのonNext、エラーを処理するonError、作業完了時に使用するonComplete、そしてパラメータとしてSubscriptionを受けるonSubscribeです。</li>
<li class="">SubscriptionのAPIは、n個のデータをリクエストするためのrequestと購読をキャンセルするためのcancelです。</li>
</ul>
<p>ここからは、Reactive Streamsで上記のAPIを使用する流れを見てみます。</p>
<ol>
<li class="">Subscriberが、subscribe関数を使用してPublisherに購読をリクエストします。</li>
<li class="">Publisherは、onSubscribe関数を使用してSubscriberにSubscriptionを送信します。<br>
<img decoding="async" loading="lazy" src="https://armeria.dev/assets/images/reactive-streams-armeria-1-9-17e45a561c31ba0d7cc7c5e6846d91fa.png" width="3332" height="1860" class="img_ev3q"></li>
<li class="">これからSubscriberは、SubscriberとPublisher間の通信を媒介します。Subscriberは、Publisherに直接データをリクエストしません。Subscriptionのrequest関数により、Publisherに送信します。</li>
<li class="">Publisherは、SubscriptionによりSubscriberのonNextにデータを送信し、完了するとonCompleteを、エラーが発生するとonErrorシグナルを送信します。</li>
<li class="">SubscriberとPublisher、Subscriptionの3つがお互い有機的に繋がって通信をやり取りし、subscribeからonCompleteまで繋がります。このようにバックプレッシャーが完成されます。</li>
</ol>
<p>バックプレッシャーが良いのは分かりますが、果たしてどのように使えばいいでしょうか。Reactive Streams APIは、<a href="https://github.com/reactive-streams/reactive-streams-jvm/tree/master/api/src/main/java/org/reactivestreams" target="_blank" rel="noopener noreferrer" class="">GitHub repo</a>にアクセスしてみても上記で確認したインターフェースがすべてです。他に実装がありません。</p>
<p>では、直接実装して使用すればいいでしょうか。前述のルール通りPublisherインターフェースを実装し、それを購読する際にSubscriptionを作成して送信するように実装することはできます。しかし、これがすべてではありません。Reactive Streamsでは、API以外にも<a href="https://github.com/reactive-streams/reactive-streams-jvm#specification" target="_blank" rel="noopener noreferrer" class="">仕様書</a>があります。この仕様書には、シンプルなインターフェースとは違って、実装の際に従うべき複雑なルールが示されています。</p>
<p><img decoding="async" loading="lazy" src="https://armeria.dev/assets/images/reactive-streams-armeria-1-10-ed725f58b4ed0796a63fd72e5956a7b2.png" width="3328" height="1866" class="img_ev3q"></p>
<p>この仕様に従って直接実装した機能は、<a href="https://github.com/reactive-streams/reactive-streams-jvm/tree/master/tck" target="_blank" rel="noopener noreferrer" class="">Reative Streams TCK</a>というツールで検証できます。当該分野の専門家でなければ、すべてのルールを満たすように実装するのはなかなか厳しいことです。特に、Publisherを実装するのが難しいです。Javaの有名なReactive Streams実装の1つである<a href="https://projectreactor.io/" target="_blank" rel="noopener noreferrer" class="">Project Reactor</a>のGitHubに登録されている課題（Issue）を見てみると、あるユーザーが自分が作ったカスタムPublisherがFluxとうまく繋がらないという内容で登録した課題があります（<a href="https://github.com/reactor/reactor-core/issues/482" target="_blank" rel="noopener noreferrer" class="">参照</a>）。これに対してProject Reactorからは、「作らないでください！」ときっぱりと回答しています。学習の意味で、ミニプロジェクトとして作るのはお勧めします。勉強にもなりますし、いいと思います。しかし、実際の運用に使用するコードであれば、検証されてないコードよりは、Flux.create()のような作成者関数を活用してPublisherを作ったほうがいいと思います。Reactive Streamsを使用するためには、直接実装するよりは既にきちんと作られて検証までされている実装を使用することをお勧めします。では、このような実装には、どのようなものがあるでしょう。</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="reactive-streamの実装と相互運用性interoperability">Reactive Streamの実装と相互運用性（interoperability）<a href="https://armeria.dev/blog/ja/2020/03/26/reactive-streams-armeria-1#reactive-stream%E3%81%AE%E5%AE%9F%E8%A3%85%E3%81%A8%E7%9B%B8%E4%BA%92%E9%81%8B%E7%94%A8%E6%80%A7interoperability" class="hash-link" aria-label="Direct link to Reactive Streamの実装と相互運用性（interoperability）" title="Direct link to Reactive Streamの実装と相互運用性（interoperability）" translate="no">​</a></h2>
<p>Reactive Streamsには<a href="https://en.wikipedia.org/wiki/Reactive_Streams#Adoption" target="_blank" rel="noopener noreferrer" class="">さまざまな実装</a>が存在します。それぞれの実装は特性が少しずつ違うため、状況と必要に応じて選んで使用できます。</p>
<ul>
<li class="">純粋に、ストリーム演算処理だけが必要なのであれば、<a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="noopener noreferrer" class="">RxJava</a>や<a href="https://github.com/reactor/reactor-core" target="_blank" rel="noopener noreferrer" class="">Reactor Core</a>、<a href="https://doc.akka.io/docs/akka/current/stream/index.html" target="_blank" rel="noopener noreferrer" class="">Akka Streams</a>などを使用します。</li>
<li class="">リポジトリのデータをReactive Streamsで取得したい場合は、<a href="http://reactivemongo.org/" target="_blank" rel="noopener noreferrer" class="">ReactiveMongo</a>や<a href="http://scala-slick.org/" target="_blank" rel="noopener noreferrer" class="">Slick</a>などを使用します。</li>
<li class="">Webプログラミングと繋がっているReactive Streamsが必要であれば、<a href="https://line.github.io/armeria/" target="_blank" rel="noopener noreferrer" class="">Armeria</a>や<a href="https://vertx.io/" target="_blank" rel="noopener noreferrer" class="">Vert.x</a>、<a href="https://www.playframework.com/" target="_blank" rel="noopener noreferrer" class="">Play Framework</a>、<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux" target="_blank" rel="noopener noreferrer" class="">Spring WebFlux</a>を活用します。</li>
</ul>
<p>このようにそれぞれ特性が違う実装ではありますが、すべてReactive Streamsでお互いに通信できます。</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="reactive-streamの相互運用">Reactive Streamの相互運用<a href="https://armeria.dev/blog/ja/2020/03/26/reactive-streams-armeria-1#reactive-stream%E3%81%AE%E7%9B%B8%E4%BA%92%E9%81%8B%E7%94%A8" class="hash-link" aria-label="Direct link to Reactive Streamの相互運用" title="Direct link to Reactive Streamの相互運用" translate="no">​</a></h3>
<p><img decoding="async" loading="lazy" src="https://armeria.dev/assets/images/reactive-streams-armeria-1-11-297565955f64bff427a1d12928ce5fc3.png" width="2866" height="1582" class="img_ev3q">
<img decoding="async" loading="lazy" src="https://armeria.dev/assets/images/reactive-streams-armeria-1-12-d033d15e15c32b4597b72cf8fc3bc910.png" width="3204" height="1398" class="img_ev3q"></p>
<p>RxJavaのObservableは、Reactive Streamsにより、ArmeriaのHttpResponseやProject ReactorのFluxに変換できます。また、MongoDBのDataPublisherはAkka StreamsのSourceによってストリーム演算ができます。</p>
<p>仮に、MongoDBで取得したデータを演算処理した後、HTTPレスポンスで送信するとします。Reactive Streamsを利用してMongoDBでデータを取得すると、まずデータの購読ができるPublisherだけ返されます。next()関数の呼び出しと同時にデータが送信されるIteratorとは違って、PublisherではSubscriberからのリクエストがないと実際のデータが送信されません。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// Initiate MongoDB FindPublisher</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">FindPublisher&lt;Document&gt; mongoDBUsers = mongodbCollection.find();</span><br></span></code></pre></div></div>
<p>以下のコードのように、ObsevableのfromPublisherを使用して、MongoDBのFindPublisherと繋げることができます。また、map演算子を利用して取得結果からageフィールドを抽出できます。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// MongoDB FindPublisher -&gt; RxJava Observable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Observable&lt;Integer&gt; rxJavaAllAges =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Observable.fromPublisher(mongoDBUsers)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              .map(document -&gt; document.getInteger("age"));</span><br></span></code></pre></div></div>
<p>RxJavaのObservableはObserverパターンで実装されているため、これをReactive Streamsに変換するためには以下のコードのようにtoFlowable関数を利用する必要があります。変換の後、Fluxのfrom関数を利用し、RxJavaのFlowableとFluxを繋げることができます。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// RxJava Observable -&gt; Reactor Flux</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Flux&lt;HttpData&gt; fluxHttpData =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Flux.from(rxJavaAllAges.toFlowable(BackpressureStrategy.DROP))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .map(age -&gt; HttpData.ofAscii(age.toString()));</span><br></span></code></pre></div></div>
<p>Fluxのデータ構造をHTTPレスポンスで使用するには、以下のようにデータの前にHTTPヘッダーを付与します。その後、ArmeriaのHTTPレスポンスとして使用するにはHttpResponse.ofを呼び出してFluxと繋げます。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// Reactor Flux -&gt; Armeria HttpResponse</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">HttpResponse.of(Flux.concat(httpHeaders, fluxHttpData));</span><br></span></code></pre></div></div>
<p>前述しましたが、肝心なことは、一般的なIteratorとは違ってPublisherでは、まだSubscriberがないためデータが送信されず、実際の演算（変換、操作、計算など）はまったく行われていないということです。ただ、データがどのようにSubscriberに流れていくか、その行為を記述しただけです。Reactive Streamsでは、Subscriberがデータをリクエストする前までは、いかなるデータも送信してはなりません。</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="おわりに">おわりに<a href="https://armeria.dev/blog/ja/2020/03/26/reactive-streams-armeria-1#%E3%81%8A%E3%82%8F%E3%82%8A%E3%81%AB" class="hash-link" aria-label="Direct link to おわりに" title="Direct link to おわりに" translate="no">​</a></h2>
<p>今回の記事では、Reactive Streamsとその実装、そして相互運用性について解説しました。Reactive Streamsをウェブプログラミングで活用するためには、HTTPリクエストとレスポンスにバックプレッシャーを利用します。Reactive Streamsを利用する場合は、バックプレッシャーによって流入されるトラフィックの量に柔軟に対応する必要があります。次回の記事では、トラフィックの量に柔軟に対応するためにArmeriaでReactive Streamsをどのように使用しているかを詳しく解説します。お楽しみに！</p>
<p>続きはこちら<br>
<a class="" href="https://armeria.dev/blog/ja/2020/03/26/reactive-streams-armeria-2">Let’s play Reactive Streams with Armeria vol.2</a></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Devoxx Belgiumで学んだ方法でKubernetes上のSpring Bootをモニタリングする]]></title>
            <link>https://armeria.dev/blog/ja/2020/01/14/monitoring-a-spring-boot-app-in-kubernetes-what-i-learned-from-devoxx-belgium-2019</link>
            <guid>https://armeria.dev/blog/ja/2020/01/14/monitoring-a-spring-boot-app-in-kubernetes-what-i-learned-from-devoxx-belgium-2019</guid>
            <pubDate>Tue, 14 Jan 2020 00:00:00 GMT</pubDate>
            <description><![CDATA[原文(投稿日:2019/12/23)はこちら]]></description>
            <content:encoded><![CDATA[<p><a class="" href="https://armeria.dev/blog/2019/12/23/monitoring-a-spring-boot-app-in-kubernetes-what-i-learned-from-devoxx-belgium-2019"><em>原文(投稿日:2019/12/23)はこちら</em></a></p>
<p>こんにちは、LINE FukuokaでサーバーサイドエンジニアをやっているTeodorです。<br>
<!-- -->11月にLINE Shopチーム(スタンプショップ、着せかえショップ、LINE STOREを開発)の他の3人のメンバーと一緒に、ベルギーのアントワープで開催されたDevoxx Belgium 2019に参加してきました。アントワープはDevoxx発祥の地で、ベルギー最大の都市でもあります。</p>
<p><img decoding="async" loading="lazy" src="https://armeria.dev/assets/images/monitoring-a-spring-boot-app-in-kubernetes-what-i-learned-from-devoxx-belgium-2019-1-8e22983a2492a8731c34a80e445decc8.jpg" width="1024" height="682" class="img_ev3q"></p>
<!-- -->
<p><a href="https://en.wikipedia.org/wiki/Devoxx" target="_blank" rel="noopener noreferrer" class="">Devoxx</a> は2001年に始まった開発者コミュニティによるカンファレンスで、あっという間にベンダー非依存としては世界最大規模のJavaカンファレンスに成長しました。 最近では、Devoxxはフランス、イギリス、ポーランド、ウクライナ、モロッコでも開催されています。</p>
<p>Deboxx Belgiumはヨーロッパで最大規模の映画館「Kinepolis」で開催されます。登壇者の映像やスライドは4Kの巨大なシネマスクリーンに投影され、THX音響が使われます。見映えは最高！</p>
<p><img decoding="async" loading="lazy" src="https://armeria.dev/assets/images/monitoring-a-spring-boot-app-in-kubernetes-what-i-learned-from-devoxx-belgium-2019-2-4530f6955b4607b56de009631379926e.jpg" width="1024" height="768" class="img_ev3q"><img decoding="async" loading="lazy" src="https://armeria.dev/assets/images/monitoring-a-spring-boot-app-in-kubernetes-what-i-learned-from-devoxx-belgium-2019-3-cebba6c5f750b3fb1e59c6d953ef9de0.jpg" width="1024" height="768" class="img_ev3q"> <img decoding="async" loading="lazy" src="https://armeria.dev/assets/images/monitoring-a-spring-boot-app-in-kubernetes-what-i-learned-from-devoxx-belgium-2019-4-a9a269fb31331861032e096fc80bd0b2.jpg" width="768" height="1024" class="img_ev3q"></p>
<p>このブログではDevoxxで学んだことを使って、Kubernetesで動くSpring Bootアプリケーションのモニタリングを行う、小さなハンズオンを行いたいと思います。 ここでは次のような事柄を説明します。</p>
<ul>
<li class="">Spring Bootアプリケーションの準備</li>
<li class="">DockerとKubernetesのインストール</li>
<li class="">Dockerイメージの作成</li>
<li class="">Kubernetesへのデプロイ</li>
<li class="">Kubernetes内のアプリケーションのモニタリング</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="モニタリングサンプル---kubernetes上のspring-bootアプリケーション">モニタリングサンプル - Kubernetes上のSpring Bootアプリケーション<a href="https://armeria.dev/blog/ja/2020/01/14/monitoring-a-spring-boot-app-in-kubernetes-what-i-learned-from-devoxx-belgium-2019#%E3%83%A2%E3%83%8B%E3%82%BF%E3%83%AA%E3%83%B3%E3%82%B0%E3%82%B5%E3%83%B3%E3%83%97%E3%83%AB---kubernetes%E4%B8%8A%E3%81%AEspring-boot%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3" class="hash-link" aria-label="Direct link to モニタリングサンプル - Kubernetes上のSpring Bootアプリケーション" title="Direct link to モニタリングサンプル - Kubernetes上のSpring Bootアプリケーション" translate="no">​</a></h2>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="1-spring-bootアプリケーションの準備">1. Spring Bootアプリケーションの準備<a href="https://armeria.dev/blog/ja/2020/01/14/monitoring-a-spring-boot-app-in-kubernetes-what-i-learned-from-devoxx-belgium-2019#1-spring-boot%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AE%E6%BA%96%E5%82%99" class="hash-link" aria-label="Direct link to 1. Spring Bootアプリケーションの準備" title="Direct link to 1. Spring Bootアプリケーションの準備" translate="no">​</a></h3>
<p>このサンプルでは、<a href="https://line.github.io/armeria/" target="_blank" rel="noopener noreferrer" class="">Armeria</a>を使った「Hello World」Spring Bootアプリケーションを使います。 LINE Shopチームでは、Armeriaを使ってハイパフォーマンスな非同期マイクロサービスを開発し、セッション層のプロトコルにはHTTP/2を使っています。<br>
<!-- -->このサンプルでも、独自のメトリクスエンドポイントをexposeしPrometheusがそこからメトリクスを参照する方法を示すためにArmeriaを使いたいと思います。Armeriaの始め方のサンプルは<a href="https://github.com/line/armeria-examples" target="_blank" rel="noopener noreferrer" class="">こちら</a>です。 今回のサンプルで使ったソースコードはこちらの<a href="https://github.com/nirvanarsc/k8s-monitoring-sample" target="_blank" rel="noopener noreferrer" class="">GitHub</a>で公開しています。動作確認はmacOSで行なっています。</p>
<p>まずは<a href="https://github.com/nirvanarsc/k8s-monitoring-sample/blob/master/src/main/java/com/github/nirvanarsc/k8s/monitoring/sample/service/GreetingService.java#L17" target="_blank" rel="noopener noreferrer" class="">gRPCサービス</a>と、<code>/internal/docs</code>でアクセスできる<a href="https://github.com/nirvanarsc/k8s-monitoring-sample/blob/master/src/main/java/com/github/nirvanarsc/k8s/monitoring/sample/service/SampleService.java#L11" target="_blank" rel="noopener noreferrer" class="">HTTPサービス</a> をセットアップします。DocServiceは、サービスの一覧を表示しテストできるようにするArmeriaが生成したシングルページのWebアプリケーションです。詳しくは<a href="https://line.github.io/armeria/server-docservice.html" target="_blank" rel="noopener noreferrer" class="">Armeriaの公式ドキュメント</a> で説明されています。</p>
<p><img decoding="async" loading="lazy" src="https://armeria.dev/assets/images/monitoring-a-spring-boot-app-in-kubernetes-what-i-learned-from-devoxx-belgium-2019-5-72863d1657c6923548295bdf10de5dba.png" width="1024" height="753" class="img_ev3q"></p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="2-dockerとkubernetesのインストール">2. DockerとKubernetesのインストール<a href="https://armeria.dev/blog/ja/2020/01/14/monitoring-a-spring-boot-app-in-kubernetes-what-i-learned-from-devoxx-belgium-2019#2-docker%E3%81%A8kubernetes%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB" class="hash-link" aria-label="Direct link to 2. DockerとKubernetesのインストール" title="Direct link to 2. DockerとKubernetesのインストール" translate="no">​</a></h3>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="docker">Docker<a href="https://armeria.dev/blog/ja/2020/01/14/monitoring-a-spring-boot-app-in-kubernetes-what-i-learned-from-devoxx-belgium-2019#docker" class="hash-link" aria-label="Direct link to Docker" title="Direct link to Docker" translate="no">​</a></h4>
<p>Kubernetesを使う前にDockerの<a href="https://docs.docker.com/install/" target="_blank" rel="noopener noreferrer" class="">インストール</a>が必要です。もしDockerが本当に初めてなら、オフィシャルの<a href="https://docs.docker.com/get-started/" target="_blank" rel="noopener noreferrer" class="">クイックスタート</a> が便利です。ここではアプリケーションのイメージをパブリックレジストリにプッシュしていきます。<a href="https://hub.docker.com/signup" target="_blank" rel="noopener noreferrer" class="">ここ</a>で登録してGUIか次のコマンドでDockerにログインしてください。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ docker login</span><br></span></code></pre></div></div>
<p>ここでログインでUsernameとして使うものに混乱するかもしれません。メールアドレスを使ってはいけません。サインアップで作成したDocker IDを使ってください。Docker IDは<a href="https://hub.docker.com/" target="_blank" rel="noopener noreferrer" class="">Docker Hub</a>にログインしたときに右上に表示されます。</p>
<p><img decoding="async" loading="lazy" src="https://armeria.dev/assets/images/monitoring-a-spring-boot-app-in-kubernetes-what-i-learned-from-devoxx-belgium-2019-6-0e05f0c7e2d267e4fa64b2789b2d3ca9.png" width="1024" height="458" class="img_ev3q"></p>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="kubernetes">Kubernetes<a href="https://armeria.dev/blog/ja/2020/01/14/monitoring-a-spring-boot-app-in-kubernetes-what-i-learned-from-devoxx-belgium-2019#kubernetes" class="hash-link" aria-label="Direct link to Kubernetes" title="Direct link to Kubernetes" translate="no">​</a></h4>
<p>オーケー、Kubernetesをインストールしましょう。このサンプルでは、Docker内のKubernetesを有効にするだけです。</p>
<p><img decoding="async" loading="lazy" src="https://armeria.dev/assets/images/monitoring-a-spring-boot-app-in-kubernetes-what-i-learned-from-devoxx-belgium-2019-7-1a01abcfce3208d0c00906f8e1305be5.png" width="1024" height="845" class="img_ev3q"></p>
<p>docker-desktop以外にローカルKubernetesクラスタを動かす手段には次のようなものがあります。</p>
<ul>
<li class=""><a href="https://github.com/kubernetes/minikube" target="_blank" rel="noopener noreferrer" class="">minikube</a></li>
<li class=""><a href="https://github.com/kubernetes-sigs/kind" target="_blank" rel="noopener noreferrer" class="">kind</a></li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="3-dockerイメージのビルド">3. Dockerイメージのビルド<a href="https://armeria.dev/blog/ja/2020/01/14/monitoring-a-spring-boot-app-in-kubernetes-what-i-learned-from-devoxx-belgium-2019#3-docker%E3%82%A4%E3%83%A1%E3%83%BC%E3%82%B8%E3%81%AE%E3%83%93%E3%83%AB%E3%83%89" class="hash-link" aria-label="Direct link to 3. Dockerイメージのビルド" title="Direct link to 3. Dockerイメージのビルド" translate="no">​</a></h3>
<p>ここまで来れば、次のコマンドが動かせるはずです。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ kubectl cluster-info</span><br></span></code></pre></div></div>
<p>そうすると、次のように表示されます。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Kubernetes master is running at https://kubernetes.docker.internal:6443</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">KubeDNS is running at https://kubernetes.docker.internal:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">To further debug and diagnose cluster problems, use 'kubectl cluster-info dump'.</span><br></span></code></pre></div></div>
<p>ここまではいい感じ。<br>
<!-- -->それでは、Spring BootアプリのDockerイメージを作りましょう。やる必要があることは、Dockerのベストプラクティス的には、docker-fileを書いてDockerデーモンを起動することです。<a href="https://spring.io/guides/topicals/spring-boot-docker/" target="_blank" rel="noopener noreferrer" class="">このガイド</a> の最初のパートに従うとよさそうです。</p>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="jib">Jib<a href="https://armeria.dev/blog/ja/2020/01/14/monitoring-a-spring-boot-app-in-kubernetes-what-i-learned-from-devoxx-belgium-2019#jib" class="hash-link" aria-label="Direct link to Jib" title="Direct link to Jib" translate="no">​</a></h4>
<p>もしくは、Jibだけでできそうです。<a href="https://github.com/GoogleContainerTools/jib" target="_blank" rel="noopener noreferrer" class="">Jib</a>はGoogleが開発した、Dockerデーモンを使わずにJavaアプリケーションのDockerイメージを構築するツールです。そして、Dockerのベストプラクティスを深く知る必要もありません。<br>
<!-- -->やる必要があるのは、<code>build.gradle</code>ファイルに次のような部分を追加することだけです。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">plugins {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ..</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    id 'com.google.cloud.tools.jib' version '1.8.0'</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">jib.to.image = 'docker_id/image_name'</span><br></span></code></pre></div></div>
<p>今回のサンプルではパブリックなDockerレジストリを使っていますが、Jibではイメージをプライベートレジストリにアップロードするようにも設定できます。<br>
<!-- -->くわしくはこちらの<a href="https://github.com/GoogleContainerTools/jib/tree/master/jib-gradle-plugin#authentication-methods" target="_blank" rel="noopener noreferrer" class="">Jibのドキュメント</a>を参照してください。</p>
<p>Jibプラグインを設定すると、Dockerイメージの作成は次のように単純になります。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ ./gradlew jib</span><br></span></code></pre></div></div>
<p>すべて完了して<a href="https://hub.docker.com/" target="_blank" rel="noopener noreferrer" class="">Docker Hub</a>へログインすると、今回のイメージがトップに現れます。</p>
<p><img decoding="async" loading="lazy" src="https://armeria.dev/assets/images/monitoring-a-spring-boot-app-in-kubernetes-what-i-learned-from-devoxx-belgium-2019-8-df9a37f4de7dd4d36a83f18a48efe014.png" width="1024" height="522" class="img_ev3q"></p>
<p>イメージのURLは<code>docker.io/docker_id/image_name</code>という形になります。</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="4-kubernetesへのデプロイ">4. Kubernetesへのデプロイ<a href="https://armeria.dev/blog/ja/2020/01/14/monitoring-a-spring-boot-app-in-kubernetes-what-i-learned-from-devoxx-belgium-2019#4-kubernetes%E3%81%B8%E3%81%AE%E3%83%87%E3%83%97%E3%83%AD%E3%82%A4" class="hash-link" aria-label="Direct link to 4. Kubernetesへのデプロイ" title="Direct link to 4. Kubernetesへのデプロイ" translate="no">​</a></h3>
<p>次はイメージをKubernetesにデプロイしましょう。そのために、YAMLの設定ファイルを書く必要があります。<a href="https://developer.ibm.com/tutorials/yaml-basics-and-usage-in-kubernetes/" target="_blank" rel="noopener noreferrer" class="">IBM</a>や<a href="https://www.mirantis.com/blog/introduction-to-yaml-creating-a-kubernetes-deployment/" target="_blank" rel="noopener noreferrer" class="">Mirantis</a>のチュートリアルが参考になりますが、基本的な.yamlファイルだけでも正しく書くのは大変な作業です。<br>
<!-- -->とはいえ、とても簡単に始める方法をDevoxxの<a href="https://www.youtube.com/watch?v=c16oOeTfFXM" target="_blank" rel="noopener noreferrer" class="">このセッション</a>でみつけました。</p>
<p>このようにする代わりに</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ kubectl create deployment my-app --image docker.io/nirvanarsc/my-app</span><br></span></code></pre></div></div>
<p><code>--dry-run</code>オプションをこのように追加します。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ kubectl create deployment my-app --image docker.io/nirvanarsc/my-app --dry-run -oyaml</span><br></span></code></pre></div></div>
<p>これで、指定したイメージをデプロイするために必要なYAMLの設定が表示されます。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">apiVersion: apps/v1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">kind: Deployment</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">metadata:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  creationTimestamp: null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  labels:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    app: my-app</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  name: my-app</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">spec:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  replicas: 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  selector:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    matchLabels:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      app: my-app</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  strategy: {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  template:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    metadata:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      creationTimestamp: null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      labels:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        app: my-app</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    spec:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      containers:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      - image: docker.io/nirvanarsc/my-app</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        name: my-app</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        resources: {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">status: {}</span><br></span></code></pre></div></div>
<p>ここで必要なのは、レプリカを1から3に増やすことです。(サンプルアプリケーションのインスタンス数を3にします)<br>
<!-- -->同じ方法で、今回のサービスの初期設定を得ることができます。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ kubectl create service clusterip my-app --tcp=8080:8080 --dry-run -oyaml</span><br></span></code></pre></div></div>
<p>これを実行すると、次のように表示されます。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">apiVersion: v1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">kind: Service</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">metadata:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  creationTimestamp: null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  labels:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    app: my-app</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  name: my-app</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">spec:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ports:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  - name: 8080-8080</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    port: 8080</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protocol: TCP</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    targetPort: 8080</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  selector:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    app: my-app</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  type: ClusterIP</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">status:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  loadBalancer: {}</span><br></span></code></pre></div></div>
<p>それでは、両方の設定をそれぞれのファイルに保存しましょう。<code>k8s</code>フォルダを作成して、次のコマンドを実行します。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ kubectl create deployment my-app --image docker.io/nirvanarsc/my-app --dry-run -oyaml &gt; k8s/deployment.yaml</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$ kubectl create service clusterip my-app --tcp=8080:8080 --dry-run -oyaml &gt; k8s/service.yaml</span><br></span></code></pre></div></div>
<p>これで、今回のアプリケーションのデプロイは次のように簡単になります。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ kubectl apply -f k8s</span><br></span></code></pre></div></div>
<p>アプリケーションにアクセスするには、外部トラフィックからKubernetesクラスタにアクセスできるようにする必要があります。</p>
<p>この記事ではIngress / LoadBalancer / NodePortなどには対処しません。おそらく<a href="https://medium.com/google-cloud/kubernetes-nodeport-vs-loadbalancer-vs-ingress-when-should-i-use-what-922f010849e0" target="_blank" rel="noopener noreferrer" class="">この投稿</a>が概要をつかむためにいいと思います。</p>
<p>ここでは代わりに、ローカルポートをクラスタのポートにフォワードするよう、次のようにします。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ kubectl port-forward svc/my-app 8080:8080</span><br></span></code></pre></div></div>
<p>これで、<code>internal/docs</code>エンドポイントや<code>internal/metrics</code>エンドポイントに<code>http://localhost:8080</code>からアクセスできるようになります。</p>
<p><img decoding="async" loading="lazy" src="https://armeria.dev/assets/images/monitoring-a-spring-boot-app-in-kubernetes-what-i-learned-from-devoxx-belgium-2019-9-72863d1657c6923548295bdf10de5dba.png" width="1024" height="753" class="img_ev3q"></p>
<p><img decoding="async" loading="lazy" src="https://armeria.dev/assets/images/monitoring-a-spring-boot-app-in-kubernetes-what-i-learned-from-devoxx-belgium-2019-10-8c715e5f0e93caec07cf919acc75c4a1.png" width="1024" height="522" class="img_ev3q"></p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="5-kubernetes内のアプリケーションのモニタリング">5. Kubernetes内のアプリケーションのモニタリング<a href="https://armeria.dev/blog/ja/2020/01/14/monitoring-a-spring-boot-app-in-kubernetes-what-i-learned-from-devoxx-belgium-2019#5-kubernetes%E5%86%85%E3%81%AE%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AE%E3%83%A2%E3%83%8B%E3%82%BF%E3%83%AA%E3%83%B3%E3%82%B0" class="hash-link" aria-label="Direct link to 5. Kubernetes内のアプリケーションのモニタリング" title="Direct link to 5. Kubernetes内のアプリケーションのモニタリング" translate="no">​</a></h3>
<p>オーケイ、ついにモニタリングの話ができるところまでやってきました。最初にPrometheusとGrafanaについて少し。</p>
<p>Prometheusはモニタリングとアラーティングのシステムです。2012年にSoundCloudで開発が始まりましたが、オープンソース化されて、今ではCNCFの一部になっています。 PrometheusはGoogleのBorgMonにインスパイアされています。BorgMonはGoogle内部で使われるモニタリング技術で、Borgで動くサービスをモニタするのに使われていました。BorgはGoogle内部クラスタのスケジューラで、Kubernetesの発想元になっています。ということで、PrometheusとKubernetesは両方ともGoogle内部の技術に由来して着想されています。</p>
<p>Grafanaはオープンソースの分析とモニタリングのシステムです。 PrometheusとGrafanaはデファクトの基本的なモニタリングソリューションになりました。GrafanaとKibanaを混同してはいけません。KibanaはElasticsearchの上で動き、ログメッセージの分析に使われます。Shopチームでも私たちはPrometheusとGrafanaをモニタリングソリューションとして使っています。</p>
<p>Prometheusを外部インスタンスで動かしてKubernetes内の今回のアプリケーションを認識しメトリクスを取得することも可能ですが、今回のサンプルでは、PrometheusとGrafanaのインスタンスをクラスタ内にインストールして、Prometheusがアプリケーションを認識してメトリクスを取ってくるようにします。</p>
<p>PrometheusとGrafanaを今回のクラスタにインストールするために、<a href="https://helm.sh/" target="_blank" rel="noopener noreferrer" class="">Helm</a>を使うことにしました。 HelmはKubernetes用のパッケージマネージャです。Kubernetes向けのnpmやaptのようなものと考えましょう。 使い始めるために<a href="https://helm.sh/docs/intro/quickstart/" target="_blank" rel="noopener noreferrer" class="">オフィシャルドキュメント</a>を確認しますが、このサンプルで必要な設定は次の通りです。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ brew install helm</span><br></span></code></pre></div></div>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ helm repo add stable https://kubernetes-charts.storage.googleapis.com/</span><br></span></code></pre></div></div>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="prometheusのインストール">Prometheusのインストール<a href="https://armeria.dev/blog/ja/2020/01/14/monitoring-a-spring-boot-app-in-kubernetes-what-i-learned-from-devoxx-belgium-2019#prometheus%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB" class="hash-link" aria-label="Direct link to Prometheusのインストール" title="Direct link to Prometheusのインストール" translate="no">​</a></h4>
<p>Prometeusをクラスタにインストールするには次のコマンドを実行します。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ helm install my-prometheus stable/prometheus</span><br></span></code></pre></div></div>
<p>これには次のような出力があるはずです。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">NAME: my-prometheus</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">LAST DEPLOYED: Thu Dec  5 15:29:58 2019</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">NAMESPACE: default</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">STATUS: deployed</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">REVISION: 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">TEST SUITE: None</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">NOTES:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">The Prometheus server can be accessed via port 80 on the following DNS name from within your cluster:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">my-prometheus-server.default.svc.cluster.local</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Get the Prometheus server URL by running these commands in the same shell:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  export POD_NAME=$(kubectl get pods --namespace default -l "app=prometheus,component=server" -o jsonpath="{.items[0].metadata.name}")</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  kubectl --namespace default port-forward $POD_NAME 9090</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">The Prometheus alertmanager can be accessed via port 80 on the following DNS name from within your cluster:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">my-prometheus-alertmanager.default.svc.cluster.local</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Get the Alertmanager URL by running these commands in the same shell:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  export POD_NAME=$(kubectl get pods --namespace default -l "app=prometheus,component=alertmanager" -o jsonpath="{.items[0].metadata.name}")</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  kubectl --namespace default port-forward $POD_NAME 9093</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">The Prometheus PushGateway can be accessed via port 9091 on the following DNS name from within your cluster:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">my-prometheus-pushgateway.default.svc.cluster.local</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Get the PushGateway URL by running these commands in the same shell:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  export POD_NAME=$(kubectl get pods --namespace default -l "app=prometheus,component=pushgateway" -o jsonpath="{.items[0].metadata.name}")</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  kubectl --namespace default port-forward $POD_NAME 9091</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">For more information on running Prometheus, visit:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">https://prometheus.io/</span><br></span></code></pre></div></div>
<p>そして次のように実行します。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ export POD_NAME=$(kubectl get pods --namespace default -l "app=prometheus,component=server" -o jsonpath="{.items[0].metadata.name}")</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  kubectl --namespace default port-forward $POD_NAME 9090</span><br></span></code></pre></div></div>
<p>そうするとPrometheusサーバーに<code>localhost:9090</code>でアクセスできるはずです。</p>
<p>しかし、<code>status/targets</code>に移動すると、Prometheusがアプリケーションの認識に失敗していることがわかります。</p>
<p><img decoding="async" loading="lazy" src="https://armeria.dev/assets/images/monitoring-a-spring-boot-app-in-kubernetes-what-i-learned-from-devoxx-belgium-2019-11-3177aada7f7d631978ce2302a70b6277.png" width="1024" height="646" class="img_ev3q"></p>
<p>ここでは、問題を解決するために2通りの方法があります。一つ目として、Helm経由でPrometheus Chartをインストールするときに<a href="https://github.com/helm/charts/blob/master/stable/prometheus/values.yaml#L1316" target="_blank" rel="noopener noreferrer" class="">追加の設定</a>を使えます。<br>
<!-- -->次のような設定の<code>extraScrapeConfigs.yaml</code>というファイルを作ることができます。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">extraScrapeConfigs: |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  - job_name: 'armeria-metrics'</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    scrape_interval: 1s</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    metrics_path: /internal/metrics</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    kubernetes_sd_configs:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      - role: endpoints</span><br></span></code></pre></div></div>
<p>そして、次のように実行してPrometheus Chartの設定を更新します。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ helm upgrade --install my-prometheus --set-file extraScrapeConfigs=prometheus/extraScrapeConfigs.yaml stable/prometheus</span><br></span></code></pre></div></div>
<p>けれども、<code>deployment.yaml</code>ファイルを変更して、Prometheusが今回のアプリケーションからメトリクスを引っ張ってこれるように次の設定を追加することをお勧めします。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">spec.template.metadata.annotations:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  prometheus.io/scrape: "true"</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  prometheus.io/port: "8080"</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  prometheus.io/path: /internal/metrics</span><br></span></code></pre></div></div>
<p>そうすると、<code>deployment.yaml</code>ファイルはこのようになるはずです。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">apiVersion: apps/v1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">kind: Deployment</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">metadata:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  creationTimestamp: null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  labels:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    app: my-app</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  name: my-app</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">spec:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  replicas: 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  selector:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    matchLabels:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      app: my-app</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  strategy: {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  template:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    metadata:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      creationTimestamp: null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      labels:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        app: my-app</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      annotations:                               ### here</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        prometheus.io/scrape: "true"</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        prometheus.io/port: "8080"</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        prometheus.io/path: /internal/metrics</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    spec:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      containers:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      - image: docker.io/nirvanarsc/my-app</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        name: my-app</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        resources: {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">status: {}</span><br></span></code></pre></div></div>
<p>それから、更新された設定でアプリケーションをデプロイしなおす必要があります。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ kubectl delete deploy/my-app svc/my-app</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$ kubectl apply -f k8s</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$ kubectl port-forward svc/my-app 8080:8080</span><br></span></code></pre></div></div>
<p>ここで<code>status/targets</code>にアクセスすると、今回のアプリケーションの3 podが見えるはずです。また、メトリクスへのクエリも可能になっているはずです。</p>
<p><img decoding="async" loading="lazy" src="https://armeria.dev/assets/images/monitoring-a-spring-boot-app-in-kubernetes-what-i-learned-from-devoxx-belgium-2019-12-a952350f9bf8708b17939060074def86.png" width="1024" height="665" class="img_ev3q"></p>
<p><img decoding="async" loading="lazy" src="https://armeria.dev/assets/images/monitoring-a-spring-boot-app-in-kubernetes-what-i-learned-from-devoxx-belgium-2019-13-382dd088b3f97b0c8f38724aa7d7c150.png" width="1024" height="396" class="img_ev3q"></p>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="grafanaのインストール">Grafanaのインストール<a href="https://armeria.dev/blog/ja/2020/01/14/monitoring-a-spring-boot-app-in-kubernetes-what-i-learned-from-devoxx-belgium-2019#grafana%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB" class="hash-link" aria-label="Direct link to Grafanaのインストール" title="Direct link to Grafanaのインストール" translate="no">​</a></h4>
<p>最後に、Grafanaをインストールしてメトリクスを可視化します。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ helm install my-grafana stable/grafana</span><br></span></code></pre></div></div>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">NAME: my-grafana</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">LAST DEPLOYED: Thu Dec  5 16:03:33 2019</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">NAMESPACE: default</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">STATUS: deployed</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">REVISION: 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">NOTES:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">1. Get your 'admin' user password by running:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   kubectl get secret --namespace default my-grafana -o jsonpath="{.data.admin-password}" | base64 --decode ; echo</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2. The Grafana server can be accessed via port 80 on the following DNS name from within your cluster:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   my-grafana.default.svc.cluster.local</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   Get the Grafana URL to visit by running these commands in the same shell:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     export POD_NAME=$(kubectl get pods --namespace default -l "app=grafana,release=my-grafana" -o jsonpath="{.items[0].metadata.name}")</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     kubectl --namespace default port-forward $POD_NAME 3000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3. Login with the password from step 1 and the username: admin</span><br></span></code></pre></div></div>
<p>続けて、上記の手順でGrafanaに<code>localhost:3000</code>でログインできるはずです。 そうすると、PrometheusをData Sourceとして追加して、今回のアプリケーションのメトリクスのダッシュボードを作れるようになります。</p>
<p><img decoding="async" loading="lazy" src="https://armeria.dev/assets/images/monitoring-a-spring-boot-app-in-kubernetes-what-i-learned-from-devoxx-belgium-2019-14-20c6d4e2bf109eed0aeac970ff02e6f7.png" width="1024" height="723" class="img_ev3q"></p>
<p><img decoding="async" loading="lazy" src="https://armeria.dev/assets/images/monitoring-a-spring-boot-app-in-kubernetes-what-i-learned-from-devoxx-belgium-2019-15-aeb013ee4a1911f79afdcc680a01e887.png" width="1024" height="317" class="img_ev3q"></p>
<p>以上です！PrometheusとGrafanaをうまく使って今回のアプリケーションのメトリクスを可視化するダッシュボードが構成できました。</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="まとめ">まとめ<a href="https://armeria.dev/blog/ja/2020/01/14/monitoring-a-spring-boot-app-in-kubernetes-what-i-learned-from-devoxx-belgium-2019#%E3%81%BE%E3%81%A8%E3%82%81" class="hash-link" aria-label="Direct link to まとめ" title="Direct link to まとめ" translate="no">​</a></h2>
<p>Kubernetesを始めることはとてもチャレンジングでしょう。その理由として3つが考えられます。</p>
<ul>
<li class="">yamlファイルをうまく書くのが難しい</li>
<li class="">ネットワークの何らかの知識が要求される</li>
<li class="">相互に結びついた小さな要素がたくさんある (Docker, Pods, Services, ReplicaSets)</li>
</ul>
<p>このブログでKubernetesでの開発を始めることが簡単になれば幸いです。</p>
<p>Happy coding!</p>
<hr>
<p>DevoxxでのKubernetesに関する役立ちそうなセッションの一覧</p>
<ul>
<li class=""><a href="https://www.youtube.com/watch?v=c16oOeTfFXM" target="_blank" rel="noopener noreferrer" class="">Best Practices to Spring to Kubernetes Easier and Faster by Ray Tsang - YouTube</a></li>
<li class=""><a href="https://www.youtube.com/watch?v=YYJ4RZFw4j8" target="_blank" rel="noopener noreferrer" class="">Develop and Deploy to Kubernetes like a Googler by David Gageot - YouTube</a></li>
<li class=""><a href="https://www.youtube.com/watch?v=YiXf4Pqyl0A" target="_blank" rel="noopener noreferrer" class="">Helm your way with Kubernetes by Ana Maria Mihalceanu - YouTube</a></li>
<li class=""><a href="https://www.youtube.com/watch?v=dId543PzSsU" target="_blank" rel="noopener noreferrer" class="">Crash course in Kubernetes monitoring by Robert Munteanu - YouTube</a></li>
</ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[GitHub Contributions グラフを緑豊かにしてみましょう(feat. Armeria Sprint)]]></title>
            <link>https://armeria.dev/blog/ja/2019/06/21/armeria-sprint-1</link>
            <guid>https://armeria.dev/blog/ja/2019/06/21/armeria-sprint-1</guid>
            <pubDate>Fri, 21 Jun 2019 00:00:00 GMT</pubDate>
            <description><![CDATA[はじめに]]></description>
            <content:encoded><![CDATA[<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="はじめに">はじめに<a href="https://armeria.dev/blog/ja/2019/06/21/armeria-sprint-1#%E3%81%AF%E3%81%98%E3%82%81%E3%81%AB" class="hash-link" aria-label="Direct link to はじめに" title="Direct link to はじめに" translate="no">​</a></h2>
<p>こんにちは。この記事を読んでいる方の中に、<a href="https://help.github.com/en/articles/viewing-contributions-on-your-profile#contributions-calendar" target="_blank" rel="noopener noreferrer" class="">GitHub contribution graph</a>が日照り状態の方はいませんか。この記事では、その日照りの解消につながるArmeria Sprintイベントとその感想を紹介します。</p>
<p>時々、技術カンファレンスのスケジュールで「スプリント（sprint）」というイベントを目にすることがあると思います（例えば、<a href="https://us.pycon.org/2019/community/sprints/" target="_blank" rel="noopener noreferrer" class="">PYCON Development Sprints</a>）。あるいは、アジャイル（agile）開発手法に登場するのでスプリントという言葉に馴染みのある方も多いでしょう。では、「オープンソーススプリント」とは何か。そしてオープンソーススプリントである「Armeria Sprint」ではどのような活動が行われたのかを紹介します。</p>
<p><img decoding="async" loading="lazy" src="https://armeria.dev/assets/images/armeria-sprint-1-1-86145b7d89389da073b2ac3d87ee8787.png" width="1276" height="172" class="img_ev3q"></p>
<!-- -->
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="オープンソーススプリントとは">オープンソーススプリントとは？<a href="https://armeria.dev/blog/ja/2019/06/21/armeria-sprint-1#%E3%82%AA%E3%83%BC%E3%83%97%E3%83%B3%E3%82%BD%E3%83%BC%E3%82%B9%E3%82%B9%E3%83%97%E3%83%AA%E3%83%B3%E3%83%88%E3%81%A8%E3%81%AF" class="hash-link" aria-label="Direct link to オープンソーススプリントとは？" title="Direct link to オープンソーススプリントとは？" translate="no">​</a></h2>
<p>オープンソーススプリントとは、オープンソースに興味を持っている人々が集まり、OSS（オープンソースソフトウェア）コントリビューションをしてみることと定義できます（OSSコントリビューションについては<a class="" href="https://armeria.dev/blog/ja/2019/05/23/thank-you-for-contributing-to-armeria">前回の記事</a>でもっと詳しく説明しているのでご参考ください）。イベントによって差はありますが、通常は1日で終わらせます。1日の場合は、午前は全員が集まってそれぞれのタスク（どのissueを担当するか）を決め、午後はコーディングに集中します。</p>
<p>参加する人は、大きくメンター（mentor）とメンティー（mentee）に分けられます。メンターは主にスプリントで扱うOSSに直接貢献した経験がある人が担当します。そして、まだ経験はないけれどこの機会に貢献してみようと参加を申し込んだ人がメンティーになります。今回のオープンソーススプリントでは、メンテナー（maintainer）である3人の方がメンターとなりました。</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="なぜ行うのか">なぜ行うのか<a href="https://armeria.dev/blog/ja/2019/06/21/armeria-sprint-1#%E3%81%AA%E3%81%9C%E8%A1%8C%E3%81%86%E3%81%AE%E3%81%8B" class="hash-link" aria-label="Direct link to なぜ行うのか" title="Direct link to なぜ行うのか" translate="no">​</a></h3>
<p>OSSコントリビューションをしてみたくても、個人的な時間を割いて作業するのはなかなか難しいですよね。また、自分一人では質問があってもどこに聞けばよいのか分からなくて迷う場合もあります。さらに、一人でやるよりも誰かと一緒に活動することでもっと頑張れる場合も多々あります。オープンソーススプリントは、このような人たちをサポートするために開かれるイベントです。具体的には、気持ちはあっても自分一人ではOSSコントリビューションに割く時間がなかったり、初めてOSSコントリビューションを試みる人たちのためのイベントです。</p>
<p>新しいコントリビュータの参加は、オープンソースコミュニティーをさらに豊かにします。メンターとして参加した場合でもメリットがあります。たとえば、さまざまな人と顔を合わせて彼らの質問に答えていくうちに、それまで新しいコントリビュータが参加できなかった原因は何かを確認できる貴重な機会になります。</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="armeria-sprintのまとめ">Armeria Sprintのまとめ<a href="https://armeria.dev/blog/ja/2019/06/21/armeria-sprint-1#armeria-sprint%E3%81%AE%E3%81%BE%E3%81%A8%E3%82%81" class="hash-link" aria-label="Direct link to Armeria Sprintのまとめ" title="Direct link to Armeria Sprintのまとめ" translate="no">​</a></h2>
<p>今回のイベントは、LINEで働く開発者から参加者を募集しました。メンターとメンティーの割合を考慮し、先着順10名とお知らせしました。募集を開始するとすぐに定員に達し、さらに10名がキャンセル待ちになるなど想定以上の反響があり非常に驚きました。参加申し込みから分かるように、みんな熱意に溢れる方でした。イベントは2日間にわたって開かれました。初日は歓迎セッションが2時間、2日目はスプリントが4時間行われました。</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="welcome-session">Welcome Session<a href="https://armeria.dev/blog/ja/2019/06/21/armeria-sprint-1#welcome-session" class="hash-link" aria-label="Direct link to Welcome Session" title="Direct link to Welcome Session" translate="no">​</a></h3>
<p>歓迎セッションは参加者の自己紹介から始まりました。その後、下記の内容を軽く説明しました。</p>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="ossコントリビューションを行う前に読んでおくこと">OSSコントリビューションを行う前に読んでおくこと<a href="https://armeria.dev/blog/ja/2019/06/21/armeria-sprint-1#oss%E3%82%B3%E3%83%B3%E3%83%88%E3%83%AA%E3%83%93%E3%83%A5%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%82%92%E8%A1%8C%E3%81%86%E5%89%8D%E3%81%AB%E8%AA%AD%E3%82%93%E3%81%A7%E3%81%8A%E3%81%8F%E3%81%93%E3%81%A8" class="hash-link" aria-label="Direct link to OSSコントリビューションを行う前に読んでおくこと" title="Direct link to OSSコントリビューションを行う前に読んでおくこと" translate="no">​</a></h4>
<ul>
<li class=""><a href="https://github.com/line/armeria/blob/master/CONTRIBUTING.md" target="_blank" rel="noopener noreferrer" class="">Contributing</a>
<ul>
<li class="">プロジェクトに貢献する方法や守るべき規則について書いてあるドキュメントです。</li>
<li class="">Armeriaでは、上記について<a href="https://github.com/line/armeria/blob/master/CONTRIBUTING.md#checklist-for-your-pull-request" target="_blank" rel="noopener noreferrer" class="">Checklist for your pull request</a>にまとめられています。きちんと確認しておくと、コードレビューにかかる時間を短縮できます。</li>
</ul>
</li>
<li class=""><a href="https://cla-assistant.io/line/armeria" target="_blank" rel="noopener noreferrer" class="">Contributor License Agreement</a>
<ul>
<li class="">普段、見過ごしがちのドキュメントです。通常、OSSコントリビューションの前に署名を求められます。</li>
<li class="">署名について短く3行でまとめてみました（プロジェクトごとに内容は異なる場合があります）。<!-- -->
<ul>
<li class="">署名の目的は、コントリビュータとプロジェクト、ユーザーを保護することです。</li>
<li class="">署名が完了されると、あなたはそれぞれ貢献した部分をArmeriaプロジェクトと同じ条件で公開することに同意することになります。</li>
<li class="">あなたの貢献は現状のままArmeriaプロジェクトに反映され、何かバグや欠陥があっても責任は負わなくてもよいことになっています。</li>
</ul>
</li>
</ul>
</li>
<li class=""><a href="https://github.com/line/armeria/blob/master/CODE_OF_CONDUCT.md" target="_blank" rel="noopener noreferrer" class="">Code of Conduct</a>
<ul>
<li class="">コミュニティーで遵守すべき行動規範です。OSSの基本精神である「自由」を追求するために守るべき行動規範を説明するドキュメントです。</li>
</ul>
</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="タスクを決める">タスクを決める<a href="https://armeria.dev/blog/ja/2019/06/21/armeria-sprint-1#%E3%82%BF%E3%82%B9%E3%82%AF%E3%82%92%E6%B1%BA%E3%82%81%E3%82%8B" class="hash-link" aria-label="Direct link to タスクを決める" title="Direct link to タスクを決める" translate="no">​</a></h4>
<p>初日に全員が集まる一番大きな理由は、それぞれのタスクを決めるためでした。全員が集まって、初心者向けのissues（<a href="https://github.com/line/armeria/issues?q=is%3Aopen+is%3Aissue+label%3Agood-first-issue" target="_blank" rel="noopener noreferrer" class="">good-first-issues</a>）を一緒に確認しました。issueごとに説明は書いてありましたが、issueが発見された背景や流れについてより詳しくメンターが説明しました。また、そのissueを解決するためには、どのような技術の背景知識が必要でどこを確認すべきか、などについてもメンターが説明しました。</p>
<p>担当するissueを決めたら、すぐにそのissueに「I am working on this」または「I'll handle this issue」のようなコメントを残します。それは、他の人と同じissueを担当しないようにするためです。</p>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="開発環境を設定する">開発環境を設定する<a href="https://armeria.dev/blog/ja/2019/06/21/armeria-sprint-1#%E9%96%8B%E7%99%BA%E7%92%B0%E5%A2%83%E3%82%92%E8%A8%AD%E5%AE%9A%E3%81%99%E3%82%8B" class="hash-link" aria-label="Direct link to 開発環境を設定する" title="Direct link to 開発環境を設定する" translate="no">​</a></h4>
<p>全員がissueを選んでから、みんなできちんと開発環境を設定しました（<a href="https://github.com/line/armeria/blob/master/CONTRIBUTING.md#setting-up-your-ide" target="_blank" rel="noopener noreferrer" class="">Setting up your IDE</a>）。</p>
<p><img decoding="async" loading="lazy" src="https://armeria.dev/assets/images/armeria-sprint-1-2-083b5bebb1c751fbb46e8b72bc4a7c2d.jpg" width="2002" height="1280" class="img_ev3q"></p>
<p>開発環境を設定するとき、「fork&amp;cloneが終わった人はペットボトルを横にしてください」という、小さな工夫を取り入れました。</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="スプリントの結果">スプリントの結果<a href="https://armeria.dev/blog/ja/2019/06/21/armeria-sprint-1#%E3%82%B9%E3%83%97%E3%83%AA%E3%83%B3%E3%83%88%E3%81%AE%E7%B5%90%E6%9E%9C" class="hash-link" aria-label="Direct link to スプリントの結果" title="Direct link to スプリントの結果" translate="no">​</a></h3>
<p>下記は、今回のスプリントで新しくオープンしたプルリクエストです。</p>
<ul>
<li class=""><a href="https://github.com/line/armeria/pull/1742" target="_blank" rel="noopener noreferrer" class="">#1742</a> Allow using wildcards with RequestContextExportingAppender</li>
<li class=""><a href="https://github.com/line/armeria/pull/1743" target="_blank" rel="noopener noreferrer" class="">#1743</a> Provide a way to create a client with an Endpoint rather than with a URI</li>
<li class=""><a href="https://github.com/line/armeria/pull/1744" target="_blank" rel="noopener noreferrer" class="">#1744</a> Show armeria version in doc service</li>
<li class=""><a href="https://github.com/line/armeria/pull/1745" target="_blank" rel="noopener noreferrer" class="">#1745</a> Enable to convert JSON format request to String</li>
<li class=""><a href="https://github.com/line/armeria/pull/1747" target="_blank" rel="noopener noreferrer" class="">#1747</a> Introduce 'export-as-curl' button to a debug request window</li>
</ul>
<p><img decoding="async" loading="lazy" src="https://armeria.dev/assets/images/armeria-sprint-1-3-e6687888fa70e93961043304b6092178.jpeg" width="4032" height="3024" class="img_ev3q"></p>
<p>今回の参加者はシャイな社員が多かったので、プライバシーを保護することにいたしました。</p>
<p><img decoding="async" loading="lazy" src="https://armeria.dev/assets/images/armeria-sprint-1-4-cc4f6442e399cee4c1ac98a48b7e8a1f.jpeg" width="3452" height="2233" class="img_ev3q"></p>
<p>自分のノートパソコンは自分で守る！パソコンから離れて食べるためなら、ピザは立ち食いでも問題なし！</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="感想">感想<a href="https://armeria.dev/blog/ja/2019/06/21/armeria-sprint-1#%E6%84%9F%E6%83%B3" class="hash-link" aria-label="Direct link to 感想" title="Direct link to 感想" translate="no">​</a></h3>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="参加者からの声">参加者からの声<a href="https://armeria.dev/blog/ja/2019/06/21/armeria-sprint-1#%E5%8F%82%E5%8A%A0%E8%80%85%E3%81%8B%E3%82%89%E3%81%AE%E5%A3%B0" class="hash-link" aria-label="Direct link to 参加者からの声" title="Direct link to 参加者からの声" translate="no">​</a></h4>
<ul>
<li class="">気軽に質問できるメンターがいること、そしてお互いを思いやる姿がよかったです。OSSに対する漠然とした恐れを減らせるこのような機会が、今後増えてほしいと思います。</li>
<li class="">説明ではきっと簡単だと思ってissueを選んだのですが、どうやらメンターに騙されたようです（笑）。しかし、OSSコントリビューションができる時間がとれたのは、大変よかったです。</li>
<li class="">開発者なら誰でも一度は「OSSコントリビューションをしてみよう」と思ったことがあるでしょう。今回のイベントは、それを始めるチャンスになったのでよかったです。</li>
<li class="">いざ解決してから見ると、実際のコーディングは数行しかなかった気がします。しかし、いろいろと考えさせられるissueでした。</li>
<li class="">issueについての説明は簡単でしたが、既存のコードを理解するのにかなりの時間がかかりました。Armeriaのコードや仕組み全体に目を通す時間が先にあったら、より簡単にアプローチできると思います。</li>
<li class="">これまで他のOSSに貢献してみようと、何度か試みたことがありますが、毎回失敗しました。今回は、メンターがそばにいたので簡単に貢献できました。</li>
<li class="">チームでArmeriaを使っています。開発していると何か必要なことが出てきますね。必要なことが出てきたときに、これからは直接貢献して修正できればいいと思って、今回のイベントに参加しました。コードを読みながらもっと勉強してみます。</li>
<li class="">私には、issueにアプローチすることが少し難しかったです。しかし今回、基本を固めることができたようでよかったです。</li>
<li class="">ある程度の機能は実装できたと思いますが、プルリクエストを送る前に時間が終わってしまったので残念です。片づけて、そのうちプルリクエストを送ります。</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="メンターからの声">メンターからの声<a href="https://armeria.dev/blog/ja/2019/06/21/armeria-sprint-1#%E3%83%A1%E3%83%B3%E3%82%BF%E3%83%BC%E3%81%8B%E3%82%89%E3%81%AE%E5%A3%B0" class="hash-link" aria-label="Direct link to メンターからの声" title="Direct link to メンターからの声" translate="no">​</a></h4>
<ul>
<li class="">OSSの開発が難しいと思う方へ：あるissueを見てどうすれば解決できるか分からない場合、どう解決すればいいのかをそのissueにコメントすることから、OSSコントリビューションが始まります。あまり心配しないで、どんどん質問してください。そのような質問が、私たちには大きく役立ちます。</li>
<li class="">このイベントで、OSSに関心を持っている開発者の仲間が、こんなにたくさんいることが分かりました。一緒に同じ空間で、助け合うことができて嬉しかったです（Starのことは、みんな忘れていないですよね？）。</li>
<li class="">初めてのイベントで少し心配しましたが、参加者のみなさんにとても真面目に取り組んでいただきました。ほんとうにありがとうございました。イベントは終わりましたが、質問があったらいつでもGitHubやSlackにメッセージを残してください。</li>
<li class="">もちろん今日、プルリクエストを送るだけでも大きな進歩でしたが、これからが本番だと言いたいです。特に、コードレビューが開発能力を高めますので、あきらめずにマージ（merge）できるまで頑張ってついてきてください。</li>
<li class="">コントリビュータと顔を合わせて、一緒に問題を解決する時間がとても意義深いものでした。今後もこのようなイベントが多く行われることを願います。</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="終わりに">終わりに<a href="https://armeria.dev/blog/ja/2019/06/21/armeria-sprint-1#%E7%B5%82%E3%82%8F%E3%82%8A%E3%81%AB" class="hash-link" aria-label="Direct link to 終わりに" title="Direct link to 終わりに" translate="no">​</a></h2>
<p>参加者のみなさん、大変お疲れさまでした。今回のイベントが共に成長できる時間であったことを望みます。また、楽しい時間を過ごせたことに感謝します。今後も、さらに充実したイベントを企画していきますので、よろしくお願いします。</p>
<p>私は、このようなイベントは初めて担当しましたが、下記の2つのドキュメントが大きく役立ちました。この場を借りて、下記のドキュメントを作成してくださった方々にも感謝申し上げます。</p>
<ul>
<li class=""><a href="https://github.com/drud/sprint_guide" target="_blank" rel="noopener noreferrer" class="">Open Source Contribution Sprint Guide by DRUD</a></li>
<li class=""><a href="https://opensourceevents.github.io/" target="_blank" rel="noopener noreferrer" class="">The In-Person Event Handbook by opensource-events</a></li>
</ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[オープンソース「Armeria」のコントリビュータのためのイベントを開催しました]]></title>
            <link>https://armeria.dev/blog/ja/2019/05/23/thank-you-for-contributing-to-armeria</link>
            <guid>https://armeria.dev/blog/ja/2019/05/23/thank-you-for-contributing-to-armeria</guid>
            <pubDate>Thu, 23 May 2019 00:00:00 GMT</pubDate>
            <description><![CDATA[はじめに]]></description>
            <content:encoded><![CDATA[<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="はじめに">はじめに<a href="https://armeria.dev/blog/ja/2019/05/23/thank-you-for-contributing-to-armeria#%E3%81%AF%E3%81%98%E3%82%81%E3%81%AB" class="hash-link" aria-label="Direct link to はじめに" title="Direct link to はじめに" translate="no">​</a></h2>
<p>こんにちは。LINEでオープンソースを担当しているイ・ソヨンです。今回の記事では、LINEが初めて実施したイベント「Armeria contributor reward」の詳細と感想をお伝えします。Armeriaの技術的な説明は割愛させていただきますので、詳しくは<a href="https://line.github.io/armeria" target="_blank" rel="noopener noreferrer" class="">公式ホームページ</a>にてご確認ください。</p>
<p><a href="https://github.com/line/armeria" target="_blank" rel="noopener noreferrer" class="">Armeria</a>は、LINEで開発してオープンソースとして公開したプロジェクトです。LINEの社内プロジェクトだったArmeriaが現在のような形になったのは、社外の多くのコントリビュータが積極的に参加してくださったためです。私たちは、そのコントリビュータの方々に感謝の気持ちをお伝えしたく、今回のイベントを企画しました。</p>
<p>本題に入る前に、まず「OSS（オープンソースソフトウェア）コントリビューション」について説明いたします。</p>
<!-- -->
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="ossコントリビューションとは">OSSコントリビューションとは？<a href="https://armeria.dev/blog/ja/2019/05/23/thank-you-for-contributing-to-armeria#oss%E3%82%B3%E3%83%B3%E3%83%88%E3%83%AA%E3%83%93%E3%83%A5%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%A8%E3%81%AF" class="hash-link" aria-label="Direct link to OSSコントリビューションとは？" title="Direct link to OSSコントリビューションとは？" translate="no">​</a></h2>
<p>社内でプロジェクトを進める際には、開発・企画・事業・デザインなど、様々な分野のメンバーが集まって一緒に仕事をします。オープンソースプロジェクトも同じです。開発のほかにも、テストやPR、デザイン、ドキュメント作成などの作業がすべて行われることで、一つの素敵なオープンソースを作り上げます。たまにOSSコントリビューションを狭義に解釈して、自分が書いたコードがプロジェクトのコードにマージされることだけに限定する場合があります。しかし、オープンソースは「コーディング」だけで作り上げられるものではありません。<strong>オープンソースの成長と維持に役立つあらゆる活動</strong>が、OSSコントリビューションであるといえます。オープンソースプロジェクトをテーマに発表してより多くの利用者を確保する、丁寧で正確なドキュメントの作成をサポートする、新しいアイデアを提案して問題解決につなげる、バグを報告する、ロゴおよびUIデザインをサポートするといった活動すべてが、OSSコントリビューションに含まれます。</p>
<p>では、オープンソース世界でコントリビュータを大事にしている理由は何でしょうか。作成者の思うとおりにしてはいけないのでしょうか。</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="ossコントリビューションが重要な理由ー作成者の観点">OSSコントリビューションが重要な理由ー作成者の観点<a href="https://armeria.dev/blog/ja/2019/05/23/thank-you-for-contributing-to-armeria#oss%E3%82%B3%E3%83%B3%E3%83%88%E3%83%AA%E3%83%93%E3%83%A5%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%8C%E9%87%8D%E8%A6%81%E3%81%AA%E7%90%86%E7%94%B1%E3%83%BC%E4%BD%9C%E6%88%90%E8%80%85%E3%81%AE%E8%A6%B3%E7%82%B9" class="hash-link" aria-label="Direct link to OSSコントリビューションが重要な理由ー作成者の観点" title="Direct link to OSSコントリビューションが重要な理由ー作成者の観点" translate="no">​</a></h3>
<p>オープンソースを作る人々と直接話し合ってみると、「プロジェクトはまだ完璧ではない、利用者の声を吸い上げてもっと発展させなければならない」という認識を常に持っていました。オープンソース活動のスポークスマン的な存在である<a href="https://ja.wikipedia.org/wiki/%E3%82%A8%E3%83%AA%E3%83%83%E3%82%AF%E3%83%BB%E3%83%AC%E3%82%A4%E3%83%A2%E3%83%B3%E3%83%89" target="_blank" rel="noopener noreferrer" class="">エリック・レイモンド氏</a>の著書『<a href="https://ja.wikipedia.org/wiki/%E4%BC%BD%E8%97%8D%E3%81%A8%E3%83%90%E3%82%B6%E3%83%BC%E3%83%AB" target="_blank" rel="noopener noreferrer" class="">伽藍とバザール</a>』では、オープンソースソフトウェアの開発方式について詳しく解説されています。利用者をはじめとする多くの人の参加がソフトウェアを一層発展させる、ということが主な内容となっています。</p>
<p>例えば、自分がレストランのオーナーで、手作りの料理を販売していると想像してみてください。同じ料理であっても、ある人にはちょうどいい味で、他の人には甘い、辛い、味が薄い、などと感じられるかもしれません。また、その中には、料理をもっとおいしく見せる食器の使い方や食卓のアレンジ方法、盛り付けのコツがわかる人がいるはずです。おすすめの料理をもっと目立たせるためのメニュー表レイアウトに詳しい人もいるでしょう。このような有益なフィードバックをすぐに受け取ることができるとしたらどうでしょうか。また、フィードバックをした人がその内容を直接反映できるようにしたらどうなるでしょうか。もっとすてきなレストランになると思いませんか。行列のできるおいしいお店として有名になるのではないでしょうか。</p>
<p>オープンソースは、利用者からのフィードバックに基づいて開発されています。オープンソースとして公開したのに利用者のフィードバックに耳を傾けないのであれば、利用者はそのオープンソースからどんどん離れていくでしょう。利用者が減ると、それに比例してプロダクトの価値も低下してしまいます。一方、利用者のフィードバックを受け入れるとしても、一人ですべてを完結させようとするとそれもやはり問題になります。利用者が増えればフィードバックも増えていきます。利用者の協力なくして、一人ですべてのフィードバックに対応するのはだんだん難しくなるはずで、それは品質低下をもたらします。そうなれば、利用者の減少は避けられません。結果的には、そのオープンソースは「死んだ」オープンソースになってしまいます。</p>
<p>利用者のフィードバックを中心に開発を進めるときは、利用者と作成者間の円滑なコミュニケーションが基盤となります。フィードバックが迅速に反映されれば利用者が増え続けるようになり、その利用者がまた開発者として貢献するようになります。このような好循環の仕組みが強固なコミュニティを構築し、オープンソースを支える役割を果たします。</p>
<p>ここまでオープンソースを作る人の観点から考えてみました。次は、オープンソースの開発に参加するコントリビュータの観点から説明いたします。</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="ossコントリビューションが重要な理由ー参加者の観点">OSSコントリビューションが重要な理由ー参加者の観点<a href="https://armeria.dev/blog/ja/2019/05/23/thank-you-for-contributing-to-armeria#oss%E3%82%B3%E3%83%B3%E3%83%88%E3%83%AA%E3%83%93%E3%83%A5%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%8C%E9%87%8D%E8%A6%81%E3%81%AA%E7%90%86%E7%94%B1%E3%83%BC%E5%8F%82%E5%8A%A0%E8%80%85%E3%81%AE%E8%A6%B3%E7%82%B9" class="hash-link" aria-label="Direct link to OSSコントリビューションが重要な理由ー参加者の観点" title="Direct link to OSSコントリビューションが重要な理由ー参加者の観点" translate="no">​</a></h3>
<p>まず、リクエストを迅速に伝えることができます。参加者が積極的に活動しているオープンソースプロジェクトは、質問を投稿すると他の利用者やメンテナー(maintainer)が素早く回答してくれます。このような速い対応によって、オープンソースがもっと使いやすくなります。また、修正したい箇所がある場合は、他の人が対応してくれるまで待つことなく、自分で修正できます。自分で修正した部分については、レビューを受けて人の意見を聞くことができます。オープンソース活動への参加は履歴として残り、誰もが閲覧できるように公開されます。こうした履歴は、就職活動中に受けるコーディングテストよりも自分自身を有効にアピールできる材料になるというメリットがあります。</p>
<p>もしかして、オープンソースプロジェクトはトップクラスの開発者だけが参加するものと思い込んで、消極的になっていませんか。この記事をきっかけに、興味を持っていたプロジェクトのIssueリストから「good-first-issue」、「first-timers-only」、または「help-wanted」などのラベルがついたものを探して、手をつけてみてはどうでしょうか。</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="armeria-contributor-rewardのご紹介">Armeria contributor rewardのご紹介<a href="https://armeria.dev/blog/ja/2019/05/23/thank-you-for-contributing-to-armeria#armeria-contributor-reward%E3%81%AE%E3%81%94%E7%B4%B9%E4%BB%8B" class="hash-link" aria-label="Direct link to Armeria contributor rewardのご紹介" title="Direct link to Armeria contributor rewardのご紹介" translate="no">​</a></h2>
<p>今回のイベントは、感謝の気持ちを伝えるとともに、コントリビュータのみなさんと交流することが目的でした。オープンソースプロジェクトの特性上、開発に参加している方々が世界各地に点在しており、コミュニケーションは主にテキストベースで行われました。「LGTM(Looks Good To Me)」または「:thumbsup:」といった短いコメントだけでは、気持ちを十分に伝えられないと常に思っていました。そのため、今回は、コントリビュータの一人ひとりに個別にメールを送って感謝の挨拶をし、小さなプレゼントを贈りました。</p>
<p>以下は、各コントリビュータの<a href="https://help.github.com/articles/personalizing-your-profile/#changing-your-profile-picture" target="_blank" rel="noopener noreferrer" class="">GitHub profile picture</a>を利用したイベント用の画像です。Armeriaのロゴのようにピンクを使った画像がさわやかですよね。</p>
<p><img decoding="async" loading="lazy" src="https://armeria.dev/assets/images/thank-you-for-contributing-to-armeria-1-3f3df0d2b8c505b2e22a7d0c13a5bd23.png" width="1000" height="333" class="img_ev3q"></p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="コントリビュータの参加">コントリビュータの参加<a href="https://armeria.dev/blog/ja/2019/05/23/thank-you-for-contributing-to-armeria#%E3%82%B3%E3%83%B3%E3%83%88%E3%83%AA%E3%83%93%E3%83%A5%E3%83%BC%E3%82%BF%E3%81%AE%E5%8F%82%E5%8A%A0" class="hash-link" aria-label="Direct link to コントリビュータの参加" title="Direct link to コントリビュータの参加" translate="no">​</a></h3>
<p>GitHubでは、コントリビュータの活動状況を<a href="https://github.com/line/armeria/graphs/contributors" target="_blank" rel="noopener noreferrer" class="">グラフ</a>で確認できます。グラフの内容を数字で表すと以下のとおりです。これまで60人以上のコントリビュータが約1,350回のコミットをして約457,000行を追加し、約257,500行を削除してくれました。数字で確認してみたら、たくさんの方々に積極的に参加していただけたことが実感できます。</p>
<p><img decoding="async" loading="lazy" src="https://armeria.dev/assets/images/thank-you-for-contributing-to-armeria-2-fcb1737125e1ea66099c22a8139ee5f9.png" width="1093" height="309" class="img_ev3q"></p>
<p>では、コントリビュータの皆さんの貢献内容をもっと詳しくみてみましょう。</p>
<ul>
<li class="">Your contribution led Armeria's annotated service to a whole new level.</li>
<li class="">Your Retrofit integration module was one of the greatest additions in Armeria's history.</li>
<li class="">HTTP redirection is now easier than ever with Armeria thanks to your contribution.</li>
<li class="">Your work on implementing the high quality circuit breaker in Armeria is considered as an all-time legend.</li>
<li class="">Your optimization of weighted round-robin load balancing algorithm was very clever idea that it was worth of a prize.</li>
<li class="">We appreciate your initial groundwork, especially on the client-side, which made today's Armeria.</li>
<li class="">Thank you for promoting Armeria to the developer communities and we appreciate your contribution to the project!</li>
<li class="">Your documentation clean-up made us look way better than ever.</li>
<li class="">Your help with fixing the bug made Armeria more stable than ever.</li>
<li class="">Although your part was small, your dedication saved many of our days.</li>
</ul>
<p>このほかにも、たくさんのコントリビュータに参加していただきました。各コントリビュータには、感謝のメッセージを個別に送りました。</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="受賞者コメント">受賞者コメント<a href="https://armeria.dev/blog/ja/2019/05/23/thank-you-for-contributing-to-armeria#%E5%8F%97%E8%B3%9E%E8%80%85%E3%82%B3%E3%83%A1%E3%83%B3%E3%83%88" class="hash-link" aria-label="Direct link to 受賞者コメント" title="Direct link to 受賞者コメント" translate="no">​</a></h3>
<p>プロジェクトに対する貢献度を示す<a href="https://github.com/line/armeria/graphs/contributors" target="_blank" rel="noopener noreferrer" class="">グラフ</a>からも分かるように、プロジェクトのオーナーを除いて最も多く貢献してくれたコントリビュータは<a href="https://github.com/line/armeria/commits?author=anuraaga" target="_blank" rel="noopener noreferrer" class="">@anuraaga</a>さんでした。この貢献度をもとに、今回のイベントでArmeria contributor rewardを受賞した<a href="https://github.com/line/armeria/commits?author=anuraaga" target="_blank" rel="noopener noreferrer" class="">@anuraaga</a>さんに感想を伺いました。</p>
<p><strong>Q</strong>. 簡単に自己紹介をお願いします。<br>
<!-- -->A. こんにちは。通称「Rag」のAnuraagです。私は様々な大規模サーバーサイドプロジェクトに携わってきたソフトウェアエンジニアです。Armeriaを初めて知ったのは、スタンプショップ、着せかえショップ、LINE STOREなどを開発するLINE Shopチームで働いていたときのことでした。本当にすごい偶然でした。私がチームに合流した後、既存の<a href="https://thrift.apache.org/" target="_blank" rel="noopener noreferrer" class="">Thrift</a>ライブラリに代わるフル機能(full-featured)の<a href="https://en.wikipedia.org/wiki/Remote_procedure_call" target="_blank" rel="noopener noreferrer" class="">RPC</a>フレームワークが必要になったからです。そこでちょうど、<a href="https://github.com/trustin" target="_blank" rel="noopener noreferrer" class="">@trustin</a>(Trustin、プロジェクトのオーナー)がそれを狙ったArmeriaプロジェクトを立ち上げたのです。その後からずっと、LINEを離れた後も、私はすべてのプロジェクトでArmeriaを使用しており、貢献できる部分がある場合はコントリビュータとしても活動しています。</p>
<p><strong>Q</strong>.
Armeriaをどう使用していますか。<br>
<!-- -->A. 仕事で、そして個人的にも、あらゆるサーバーサイド開発においてArmeriaを使用しています。私が働いている<a href="https://www.infostellar.net/" target="_blank" rel="noopener noreferrer" class="">Infostellar</a>社は、衛星通信のためのグローバル・ネットワーク・インフラの構築に取り組んでいますが、一般的なAPI要件を満たすことはもちろん、大量のデータを送信することも求められます。弊社のアーキテクチャは、一般的なサービスベース・アーキテクチャに従っています。数多くのサーバーが<a href="https://kubernetes.io/" target="_blank" rel="noopener noreferrer" class="">Kubernetes</a>上で実行されるので、Armeriaを使って<a href="https://grpc.io/" target="_blank" rel="noopener noreferrer" class="">gRPC</a> APIを公開しています。また、Armeriaの静的ファイル配信機能とgRPC-Web対応によって提供されるWebフロントエンドもあります。<br>
<!-- -->仕事で使うだけでなく、週末に個人的に進めているプロジェクトにおいてもArmeriaを使っています。必要なユースケースに合わせて様々な規模のプロジェクトでArmeriaを有効に使用することができて嬉しいです。</p>
<p><strong>Q</strong>.
Armeriaの一番の長所は何ですか。<br>
<!-- -->A.
Armeriaの一番の長所は、開発者の生産性に焦点を当てていることだと思います。Trustinは、すべての開発者のニーズを満たせるプロジェクトを作り上げたといえます。Armeriaは、非常に高い柔軟性を誇っており、ベストプラクティスを示してくれるだけでなく、「非同期(asynchronous)プログラミング」などの最新トレンドを開発者に紹介してくれます。メンテナーが非常に理論的に対応するフレームワークやライブラリもありますが、そのような運営スタイルだと、プロジェクトが開発者ではなくメンテナーが求める方向に進んでいき、開発者としては使いにくいライブラリになってしまいます。Armeriaは、Slackチャネルを利用して全面的にサポートするなど、開発者のニーズにフォーカスしているので、様々な分野の開発者に役立つと思います。<br>
<!-- -->また、Armeriaはこれまで見たフレームワークの中で一番柔軟性の高いサーバーフレームワークです。同じTCPポートでgRPCや静的ファイル(static files)、<a href="https://dzone.com/articles/metrics-for-microservices" target="_blank" rel="noopener noreferrer" class="">metrics</a>、<a href="https://line.github.io/armeria/server-docservice.html#server-docservice" target="_blank" rel="noopener noreferrer" class="">DocService</a>、その他のコンテンツをすべて提供できるということは、とても大きな成果だと思います。</p>
<p><strong>Q</strong>.
Armeriaの開発に参加して大変だったことはありますか。<br>
<!-- -->A.
Armeriaを開発しながら大変だったことは特にありません。Armeriaはドキュメントがしっかりされていて、IDE(統合開発環境、Integrated Development Environment)の設定もわかりやすく解説されています。また、親切なレビュアーさんのおかげでPR(Pull Request)もスムーズに処理されます。一時的でしたが、リリース作業が少し遅れると感じたことはありました。バグ修正はマージされたのにリリースがされず、バグ修正が含まれたスナップショットを配布したことがありましたね。でも、最近は頻繁にリリースされているので、遅いと感じたりすることはありません。<br>
<!-- -->また、些細なことではありますが、空白を正しく適用することはたぶん修正が難しいのではないかと思います。私はインポートしたコード設定を使っていますが、それにもかかわらず、空白を正しく適用するのが難しいです。特に、私が見逃したいくつかの空白をTrustinが発見し、後で別のPRを作成して修正しているのを見ると、恥ずかしい気持ちになりますね。 自動フォーマッター(formatter)を使用すれば、開発時の懸念材料が一つ減ると思います。</p>
<p><strong>Q</strong>. プロジェクトについて、今後計画していることや期待していることはありますか。<br>
<!-- -->A. 個人的には、使えそうな機能が見つかればコードに貢献するなど、これからも引き続きArmeriaを使用する予定です。実は、これはいい質問なんですね。私にはプロジェクトに寄せられている期待については詳しくないのですが、Armeriaには機能リクエストがたくさん寄せられます。その中には、限られた範囲の技術を使ったリクエストもよくあります。今思い出せる<a href="https://github.com/line/armeria/issues/194" target="_blank" rel="noopener noreferrer" class="">例</a>としては、より多くの<a href="https://microservices.io/patterns/client-side-discovery.html" target="_blank" rel="noopener noreferrer" class="">サービス・ディスカバリ</a>のメカニズムのサポートを追加する件がありますね。また、<a href="https://spring.io/projects/spring-security" target="_blank" rel="noopener noreferrer" class="">Spring Security</a>を標準でサポートするかどうかという件もあります。Armeriaが世界中のあらゆる技術をすべてサポートするには無理があると思いますが、そのスコープをどう定めればいいか悩ましいところです。</p>
<p><strong>Q</strong>. オープンソース(またはOSSコントリビューション)について一言お願いします。<br>
<!-- -->A. オープンソース大好き！オープンソースは、開発者に有用な技術を作り上げるとともに、強力なコミュニティを形成する役割もしていると思います。オープンソースを通じてたくさんの仲間に出会うことができて驚きましたし、そして本当に嬉しいです。これからも、オープンソース活動に取り組みながら、より多くの人と交流できることを楽しみにしています。周りの人にも、暇があるときに好きなリポジトリにPRを送ってみるように勧める予定です。</p>
<p><strong>Q</strong>. 最後に何か言いたいことはありますか。<br>
<!-- -->A. このようなイベントがあって本当に楽しいです。LINEのようなリーディングカンパニーがオープンソースの拡大に重点を置いていることは素晴らしいことです。企業がソースコードをいくつか公開するのは簡単ですが、このようにエコシステム自体を支援するのは簡単なことではありません。オープンソースコミュニティの構築に協力してくれたことに本当に感謝しています。</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="終わりに">終わりに<a href="https://armeria.dev/blog/ja/2019/05/23/thank-you-for-contributing-to-armeria#%E7%B5%82%E3%82%8F%E3%82%8A%E3%81%AB" class="hash-link" aria-label="Direct link to 終わりに" title="Direct link to 終わりに" translate="no">​</a></h2>
<p>今回の「Armeria contributor reward」は、私が初めて運営を担当したイベントでしたが、色々新しい経験ができて楽しかったです。このような楽しい経験ができるのが、オープンソースの魅力なのではないでしょうか。</p>
<p>Armeriaで新しい経験をしてみたい方は、まず「<a href="https://github.com/line/armeria/issues?q=is%3Aopen+is%3Aissue+label%3Agood-first-issue" target="_blank" rel="noopener noreferrer" class="">good-first-issue</a>」から確認してみてください。Armeriaをすでに使い慣れている方は、現在1.0.0バージョンをリリースするために必要なことをまとめていますので、<a href="https://github.com/line/armeria/issues/1704" target="_blank" rel="noopener noreferrer" class="">こちら</a>に皆さんのアイデアをぜひお寄せください。</p>
<p>Armeriaでは、より多くの利用者とコントリビュータを確保するために、様々なプログラムを企画しています。今後のイベントについても、今回と同様に<a href="https://engineering.linecorp.com/ja/blog/" target="_blank" rel="noopener noreferrer" class="">LINE Engineering blog</a>と<a href="https://line-armeria.slack.com/join/shared_invite/enQtNjIxNDU1ODU1MTI2LTgwMzk0MzVhOGRhZjJiY2ExODc0MzNhYzIxZDFlYjM5OGRjNTE1MzYzYzQ4MzNhNGY2ZDM0NThhMTRmZmQ3ZjQ" target="_blank" rel="noopener noreferrer" class="">公式Slack</a>で情報をお届けいたします。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[RxJava 2とArmeriaでマイクロサービスを非同期化してみた]]></title>
            <link>https://armeria.dev/blog/ja/2017/12/01/asynchronous-micro-service-in-rxjava-2-armeria</link>
            <guid>https://armeria.dev/blog/ja/2017/12/01/asynchronous-micro-service-in-rxjava-2-armeria</guid>
            <pubDate>Fri, 01 Dec 2017 00:00:00 GMT</pubDate>
            <description><![CDATA[こんにちは、LINEメッセンジャーのサーバーサイド開発チームに所属してスタンプや着せかえに関連する開発を担当している川田（@hktechno）です。この記事はLINE Advent Calendar 2017の2日目の記事です。]]></description>
            <content:encoded><![CDATA[<p>こんにちは、LINEメッセンジャーのサーバーサイド開発チームに所属してスタンプや着せかえに関連する開発を担当している川田（@hktechno）です。この記事は<a href="https://engineering.linecorp.com/ja/blog/detail/210" target="_blank" rel="noopener noreferrer" class="">LINE Advent Calendar 2017</a>の2日目の記事です。</p>
<p>私が所属しているチームは、数年前からマイクロサービス化されたサービスのRPC（Remote Procedure Call）やDBアクセスを非同期化し、レイテンシの削減やサーバーリソースの省力化に勤しんできました。最近は、LINE内部で開発しているRPCサーバー<a href="http://line.github.io/armeria/" target="_blank" rel="noopener noreferrer" class="">Armeria</a>と<a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="noopener noreferrer" class="">RxJava 2</a>を使って、“Javaにしては”なかなかイケている内部構成になってきました。この記事では、そんな私達のチームで開発しているスタンプ・着せかえ関連サーバーの裏側についてご紹介したいと思います。</p>
<!-- -->
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="line-shopにおけるマイクロサービス">LINE Shopにおけるマイクロサービス<a href="https://armeria.dev/blog/ja/2017/12/01/asynchronous-micro-service-in-rxjava-2-armeria#line-shop%E3%81%AB%E3%81%8A%E3%81%91%E3%82%8B%E3%83%9E%E3%82%A4%E3%82%AF%E3%83%AD%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9" class="hash-link" aria-label="Direct link to LINE Shopにおけるマイクロサービス" title="Direct link to LINE Shopにおけるマイクロサービス" translate="no">​</a></h2>
<p>一言でLINEといっても、LINEと名前のつくサービスはたくさんありますが、私達のチームでは、LINEメッセンジャー内で使えるデジタルコンテンツのうち、主にスタンプと着せかえを提供するシステムを開発していて、それらのシステムやチーム全体のことをLINE Shopと呼んでいます。LINE Shopのシステムでは、ショップ向けのAPI提供はもちろん、<a href="https://store.line.me/" target="_blank" rel="noopener noreferrer" class="">LINE STORE</a>というサイトや、メッセージを実際にやり取りするサーバーと連携するサービスなど、複数のサービスを管理しています。</p>
<p>マイクロサービスという言葉が流行り始めてからもう数年が過ぎますが、LINEでは早くからマイクロサービスアーキテクチャを取り入れていて、スタンプショップや着せかえショップの内部も細かいサービスに切り出されています。例えば、スタンプメッセージをやり取りする際に必要なバリデーションなどは、LINEの根幹となるメッセージ送信サーバーでは行なわず、マイクロサービスとして切り出して私達のチームで管理していますし、<a href="https://engineering.linecorp.com/ja/blog/detail/99" target="_blank" rel="noopener noreferrer" class="">昨年のAdvent Calendar</a>で紹介したように、ショップ向けの検索やランキングリスト向けのCache＋Queryを行うサーバーは別なサーバーとして動作しています。</p>
<p><img decoding="async" loading="lazy" alt="LINE Shop Architecture" src="https://armeria.dev/assets/images/asynchronous-micro-service-in-rxjava-2-armeria-1-c21f929f375484f08ce8cdfdc2105dfc.png" width="766" height="508" class="img_ev3q"> 'LINE Shopのアーキテクチャ（かなり簡略化されています）'</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="マイクロサービス化した場合に問題になりそうなこと">マイクロサービス化した場合に問題になりそうなこと<a href="https://armeria.dev/blog/ja/2017/12/01/asynchronous-micro-service-in-rxjava-2-armeria#%E3%83%9E%E3%82%A4%E3%82%AF%E3%83%AD%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9%E5%8C%96%E3%81%97%E3%81%9F%E5%A0%B4%E5%90%88%E3%81%AB%E5%95%8F%E9%A1%8C%E3%81%AB%E3%81%AA%E3%82%8A%E3%81%9D%E3%81%86%E3%81%AA%E3%81%93%E3%81%A8" class="hash-link" aria-label="Direct link to マイクロサービス化した場合に問題になりそうなこと" title="Direct link to マイクロサービス化した場合に問題になりそうなこと" translate="no">​</a></h3>
<p>マイクロサービスを増やしていくと、それぞれのサービスがAPIによって接続され、たくさんのRPC（Remote Procedure Call）を行うようになります。しかし、RPCを1つのリクエスト内部でたくさん行う場合は、考えなければいけないことがいくつかあります。そのうちの1つが、RPCを行うためにかかるレイテンシが、逐次的に実行した場合に意外と大きくなってしまうことです。</p>
<p>例えば、あるRPCで1回あたりのレイテンシが10msかかる状況では、100回RPCを行うときに同期的なAPIで100回呼び出すと、1000msかかります。さらに、以下のような状況を考えてみてください。</p>
<ul>
<li class="">Aを100回取得する（10ms）。</li>
<li class="">それぞれのA.idを使ってBとCを取得する（B 10ms、C 10ms）。</li>
<li class="">すべてのデータ（A、B、C）を利用してDを作成してレスポンスを返す。</li>
</ul>
<p>このように逐次的にDを100個取得するような状況では、レスポンスまで3000msかかってしまう可能性があります。マイクロサービス化したりDBクエリを実行したりする際に、このような設計にするべきではありませんが、それぞれをキャッシュできる場合などはこうしたほうが良い場合も多いでしょう。</p>
<p>今回はマイクロサービスのRPCを例としましたが、DBアクセスでも同様の状況になることが考えられます。マイクロサービス化されたサービス間のRPCの場合には、それぞれが担っている領域が違うために、DBのクエリレベルで最適化されたものでないことが普通でしょう。例えば、認証、プロダクト情報、ユーザーの所有権などが複雑に絡み合い、全く違うDB・サービスとして提供されているような状況を考えてみてください。</p>
<p>このような場合、よくRPCやDBアクセスを何らかの方法で並列化すると思います。RPCを行うためにスレッドを作って並列化することで、それぞれの段階を並列化することができます。上記の例では、理論上最短でレイテンシを20msに短縮することができます。Javaであれば、通常ThreadPoolExecutorを利用するのではないでしょうか。その他の言語であっても、最近では簡単にマルチスレッドでプログラムを実行することができるようになっています。</p>
<p><img decoding="async" loading="lazy" alt="Sync API" src="data:image/png;base64,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" width="906" height="230" class="img_ev3q"> '同期API＋スレッドプール'</p>
<p>スレッドプールを利用した例</p>
<p>これで、めでたしめでたし、となるとよいのですが、実際のところはそう簡単に物事は進みません。</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="同期的synchronousapiとスレッドプール">同期的（Synchronous）APIとスレッドプール<a href="https://armeria.dev/blog/ja/2017/12/01/asynchronous-micro-service-in-rxjava-2-armeria#%E5%90%8C%E6%9C%9F%E7%9A%84synchronousapi%E3%81%A8%E3%82%B9%E3%83%AC%E3%83%83%E3%83%89%E3%83%97%E3%83%BC%E3%83%AB" class="hash-link" aria-label="Direct link to 同期的（Synchronous）APIとスレッドプール" title="Direct link to 同期的（Synchronous）APIとスレッドプール" translate="no">​</a></h3>
<p>RPCを行う際の同期的なAPIの問題点は何でしょうか。それは、RPCの結果を取得するまで、他の処理を実行できないことです。前述のように、スレッドプールを利用して、RPCやDBに対して同期的なAPIを使って並列にリクエストを行った場合、利用するスレッドはそのレスポンスが返ってくるまで、その1つのリクエストに専有されてしまいます。C10K問題という単語を聞いたことがある方もいるかと思いますが、だいたいあれと同じことです。</p>
<p>例えば、以下の状況を考えてみましょう。</p>
<ul>
<li class="">API AはAPI Bを100回呼び出す。</li>
<li class="">API Bは1回あたり100msでレスポンスを返す。</li>
<li class="">API Aは平均で毎秒1000回呼び出される。</li>
</ul>
<p>この場合、1秒間に生成されるジョブの数は1000 × 100 = 100,000です。それぞれの処理に100msかかるのであれば、スレッドプールの最大生成スレッド数が1,000であった場合に、計算上は遅延せずに処理できることになります。そうでない場合には、処理が遅延していくことになりますし、そうでなかったとしても、API Aのレスポンスにかかる時間は通常100msより長くなります。</p>
<p>このような状況は、普段は問題にならないかもしれません。しかし、リクエストが集中して高負荷になったときに、DBやアクセス先のサーバーはまだ処理できる状態であっても、RPCをたくさん受け付けているサーバーがスレッドプールの限界を迎えたり、逆にそのサーバーのCPUは余裕があるのにDBのレイテンシが悪化して、スレッドプールが限界を迎えたりすることがあります。つまり、スレッドプールを使うと、リソースが限界に近いときに、RPCやDBのレイテンシに敏感なサーバーになってしまうことになります。</p>
<p>以下は、<a href="https://github.com/openzipkin/zipkin" target="_blank" rel="noopener noreferrer" class="">Zipkin</a>を利用して、DBやそれぞれのマイクロサービスをまたいで、LINE Shop内部のサーバーのリクエストの流れを可視化した図です。この例は、購入済み商品の一覧を取得する、実際に動作しているAPIの内部フローです。1つのAPIリクエストで、3つのマイクロサービスを経由して、MongoDBとRedis Cacheに複数回アクセスしていることがわかります。この例では画像の縦サイズの都合上、DBへのアクセスはそれほど多くありませんが、それでも、同期的APIを利用した場合は1リクエストあたり多くのスレッドが必要であることがわかると思います。</p>
<p><img decoding="async" loading="lazy" alt="Armeria Zipkin Integration" src="https://armeria.dev/assets/images/asynchronous-micro-service-in-rxjava-2-armeria-3-2bbc59d51090b480b7b10614f6c83ef7.png" width="2704" height="1730" class="img_ev3q"> 'Armeria Zipkin Integration'</p>
<p>もっとたくさんスレッドを作ればいいじゃないかと思うかもしれませんが、スレッドをたくさん作る事自体がコストになりますし、スレッドプールを使ったとしてもその数を大きくしすぎると、コンテキストスイッチのコストが大きく効率的ではありません。通常は私達のチームでは、1つのスレッドプールの上限は多くても1000程度に設定しています。</p>
<p>RPCやDBへのアクセスは、ただリクエストを投げてそれが返ってくるまで待つだけなので、基本的に他に何も処理するべきことはありません。つまり、何らかのデータをほぼ右から左に流すだけの処理です。しかし、CPUに余裕があっても、外部のリクエスト数が多くレイテンシがそれなりにかかる場合は、スレッドプールの限界を迎えてしまい、結果的にサーバーを増やすしかなくなってしまいます。</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="非同期asynchronousapi">非同期（Asynchronous）API<a href="https://armeria.dev/blog/ja/2017/12/01/asynchronous-micro-service-in-rxjava-2-armeria#%E9%9D%9E%E5%90%8C%E6%9C%9Fasynchronousapi" class="hash-link" aria-label="Direct link to 非同期（Asynchronous）API" title="Direct link to 非同期（Asynchronous）API" translate="no">​</a></h2>
<p>上記のような、同期的なAPIとスレッドプールの組み合わせにより発生する問題を解決するために、非同期（Asynchronous、Async）なAPIを利用します。長々と前置きをしてきましたが、非同期APIを利用するのは、右から左に流すだけの処理をなるべく並列化して効率的に行いたいからです。</p>
<p>マイクロサービスのアーキテクチャでは、ユーザーからAPIリクエストを受けるような上位に位置するサービスは、ほとんどの場合、ただ右から左にリクエストを流したり、複数のRPCのレスポンスを結合したりするだけです。また、その他のサービス内部でも、多くの場合、DBはCPUやメモリをたくさん使って処理を行いますが、それをリクエストするアプリケーションサーバーは、ただレスポンスを受けてデータを変換したりするだけだったりするでしょう。</p>
<p>特に、LINE Shopで管理しているサービスでは、<a href="https://store.line.me/" target="_blank" rel="noopener noreferrer" class="">LINE STORE</a>を提供しているサーバー以外で、サーバーサイドでテンプレートエンジンを利用したHTMLレンダリングを行っていません。多くの場合、CPUリソースを消費するような処理は、ほとんど行われません。一番CPUを食うのは、JSONや、その他RPCやキャッシュのために利用するプロトコルのための、シリアライズやデシリアライズだったりするのではないでしょうか。</p>
<p>このようなサービスのために、たくさんのサーバーを使いたくないですし、なるべくたくさんのリクエストを同時に、かつ効率的に、できれば、そのマシンが耐えうるネットワーク帯域幅の限界まで処理を受け付けられるようにしたいのです。マイクロサービス化すると、必然的にそれぞれのサービスでやることは分散され小さくなるので、いかに多くのリクエストをそれぞれのサーバーで処理できるかが、無駄なリソースを減らすために重要になってきます。</p>
<p><img decoding="async" loading="lazy" alt="Async API" src="data:image/png;base64,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" width="866" height="215" class="img_ev3q"> '非同期API＋イベントループ'</p>
<p>非同期API＋イベントループの例</p>
<p>非同期APIといわれても、非同期という概念についていまいちぱっと思い浮かぶイメージがない方も多いと思います。簡単に言ってしまえば、JavaのFutureであったり、RxJavaのSingleであったり、Pythonであればasyncioだったりというものです。これらを使ったことがある方であれば、なんとなくイメージが湧くかもしれません。何か処理を実行して、計算が終了したときに通知してくれたり、次に行う処理（コールバック）を指定できたりするような仕組みが非同期APIです。何か非同期処理を行う関数を実行しても、その関数自体は処理が終了していなくてもブロックせずに終了します。</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="非同期apiの例">非同期APIの例<a href="https://armeria.dev/blog/ja/2017/12/01/asynchronous-micro-service-in-rxjava-2-armeria#%E9%9D%9E%E5%90%8C%E6%9C%9Fapi%E3%81%AE%E4%BE%8B" class="hash-link" aria-label="Direct link to 非同期APIの例" title="Direct link to 非同期APIの例" translate="no">​</a></h3>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 非同期APIを利用してProductからAuthorを取得する</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// CompletableFutureの例</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">someAsyncDriver.getProdut(id) // ブロックしない</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// -&gt; CompletableFuture&lt;Product&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               .thenCompose(product -&gt; product.getAuthor());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// -&gt; CompletableFuture&lt;Author&gt;</span><br></span></code></pre></div></div>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="非同期apiを利用するメリット">非同期APIを利用するメリット<a href="https://armeria.dev/blog/ja/2017/12/01/asynchronous-micro-service-in-rxjava-2-armeria#%E9%9D%9E%E5%90%8C%E6%9C%9Fapi%E3%82%92%E5%88%A9%E7%94%A8%E3%81%99%E3%82%8B%E3%83%A1%E3%83%AA%E3%83%83%E3%83%88" class="hash-link" aria-label="Direct link to 非同期APIを利用するメリット" title="Direct link to 非同期APIを利用するメリット" translate="no">​</a></h3>
<p>サーバー内で効率的にリクエストを処理するために、まずサービス内部でRPCやDBへのリクエストを行う際に、それらのクライアントに備わっている非同期APIを利用します。きちんと実装された非同期APIでは、RPCやDBへクエリを行う際に、スレッドを専有することなく処理を行うことができます（注：Futureを返却するAPIでも、実装によっては内部でリクエスト毎にスレッドを生成している場合があり注意が必要です）。最近では、多くのDBクライアントやRPCライブラリが非同期APIを提供しており、各言語で非同期APIを利用することができます。例えば、LINE ShopではJava 8を使っていますが、以下のようなライブラリが提供する非同期APIを利用しています。これらのライブラリの内部的な仕組みはさまざまで、詳細に説明しているとネットワークライブラリ（Java NIOやNetty）や、OSのシステムコール（例えばselectやepoll）の話をしなくてはいけなくなるので、この記事では省きます。</p>
<ul>
<li class="">Thrift RPC：<a href="http://line.github.io/armeria/" target="_blank" rel="noopener noreferrer" class="">Armeria</a></li>
<li class="">HTTP RESTful API：<a href="http://square.github.io/retrofit/" target="_blank" rel="noopener noreferrer" class="">Retrofit</a> (<a href="https://line.github.io/armeria/client-retrofit.html" target="_blank" rel="noopener noreferrer" class="">Armeria Retrofit</a>)</li>
<li class="">Redis：<a href="https://lettuce.io/" target="_blank" rel="noopener noreferrer" class="">Lettuce</a></li>
<li class="">MongoDB：<a href="http://mongodb.github.io/mongo-java-driver/3.5/driver-async/" target="_blank" rel="noopener noreferrer" class="">MongoDB Async Java Driver</a></li>
<li class="">Elasticsearch：<a href="https://www.elastic.co/guide/en/elasticsearch/client/java-api/current/java-api.html" target="_blank" rel="noopener noreferrer" class="">Java API</a></li>
<li class=""><a href="https://kafka.apache.org/090/javadoc/index.html?org/apache/kafka/clients/producer/KafkaProducer.html" target="_blank" rel="noopener noreferrer" class="">Apache Kafka</a></li>
</ul>
<p>多くのライブラリではリクエスト毎にスレッドを生成することはしません。基本的にはリクエストの送受信時に通知を受けて処理するために限られた数のスレッドを使い、そのスレッド数よりはるかに多くのリクエストを並列に処理しています。イベントループのような仕組みを使って、CPUのコア数程度のスレッドを作り、それぞれのスレッドでリクエスト・レスポンスの処理を行い、キャッシュ効率向上や無駄なコンテキストスイッチコストの削減を実現することができます（例えば、JavaのForkJoinPoolを利用すると、このような処理が簡単に行なえます）。</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="リクエストからレスポンスまで完全に非同期に">リクエストからレスポンスまで完全に非同期に<a href="https://armeria.dev/blog/ja/2017/12/01/asynchronous-micro-service-in-rxjava-2-armeria#%E3%83%AA%E3%82%AF%E3%82%A8%E3%82%B9%E3%83%88%E3%81%8B%E3%82%89%E3%83%AC%E3%82%B9%E3%83%9D%E3%83%B3%E3%82%B9%E3%81%BE%E3%81%A7%E5%AE%8C%E5%85%A8%E3%81%AB%E9%9D%9E%E5%90%8C%E6%9C%9F%E3%81%AB" class="hash-link" aria-label="Direct link to リクエストからレスポンスまで完全に非同期に" title="Direct link to リクエストからレスポンスまで完全に非同期に" translate="no">​</a></h3>
<p>もちろん、RPCやDBへのアクセス部分だけでも非同期化することでかなりの効果が得られるのですが、最大限効果を得るためには、サーバーのネットワークから来るリクエスト処理からRPCやDBへのリクエストを経て、レスポンスを返すまですべてを非同期化するべきです。いったんどこかで同期的な処理にまとめてしまうと、またそこでスレッド数の問題が発生することが少なくないからです。また、後ほど説明するとおり、非同期APIと同期APIの混在は、イベントループの方式を利用した場合、コーディングミスによりリクエストをブロックしてしまうようなことが簡単にできてしまうこともあり、これを防ぐためでもあります。</p>
<p>さらに、上から下まで完全に非同期で書かれたサービスは、それぞれのサービスのレイテンシの低下にそれほど敏感になる必要がなくなります。なぜなら、レスポンスがいくら遅くてもスレッドを専有しないので、通常はただレスポンスが返ってこないだけです。よって、スレッドプールを利用した場合のように、スレッドの上限を気にする必要がなくなります。</p>
<p>サーバーの受け側を非同期化するためには、そのリクエストを処理するフレームワークも非同期APIに対応している必要があります。Javaであれば、よく利用されるSpring FrameworkだとDeferredResultが非同期処理を行うインターフェースとして利用できます。最近では、Spring WebFluxなどサーブレットに依存しないフレームワークが出現して、非同期化の機運が高まっています。そんな世の中ですが、LINE Shopでは、これから説明するArmeriaという自社開発RPCフレームワークを使い、非同期化を行っています（Spring も同時に利用しています）。</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="armeriaとthrift">ArmeriaとThrift<a href="https://armeria.dev/blog/ja/2017/12/01/asynchronous-micro-service-in-rxjava-2-armeria#armeria%E3%81%A8thrift" class="hash-link" aria-label="Direct link to ArmeriaとThrift" title="Direct link to ArmeriaとThrift" translate="no">​</a></h2>
<p>LINEでは、LINE Shopに限らずメッセンジャーに関連する多くのRPCが<a href="https://thrift.apache.org/" target="_blank" rel="noopener noreferrer" class="">Apache Thrift</a>と呼ばれるRPCフレームワークを利用して行われています。Thriftは、APIの定義、リクエスト・レスポンスのスキーマの定義を専用のIDLを用いて行うことで、それぞれの言語で利用できるRPCライブラリを自動生成してくれます。最近では、同様のフレームワークにProtocol Buffersを利用した<a href="https://grpc.io/" target="_blank" rel="noopener noreferrer" class="">gRPC</a>があります。LINE Shopでは、JSONを利用したRESTfulなAPIはほとんど使われていません。個人的には、マイクロサービスをやるならJSONを使うのはもうダサいと思っています。遅いし、普通はAPIを内部でしか使わないので。</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="thrift-idlの例">Thrift IDLの例<a href="https://armeria.dev/blog/ja/2017/12/01/asynchronous-micro-service-in-rxjava-2-armeria#thrift-idl%E3%81%AE%E4%BE%8B" class="hash-link" aria-label="Direct link to Thrift IDLの例" title="Direct link to Thrift IDLの例" translate="no">​</a></h3>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct GetProductRequest {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    1: ProductType type,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    2: string productId,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct Product {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    1: ProductType type,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    2: string productId,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">service ShopService {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Product getProduct(1:GetProductRequest request) throws (1:ShopException e)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>そんな中、LINEでは<a href="http://line.github.io/armeria/" target="_blank" rel="noopener noreferrer" class="">Armeria</a>というオープンソースのHTTP/2対応Java向け非同期RPCライブラリを公開しています。簡単に言うと、ArmeriaはThriftやgRPCを使って定義したAPIを使うためのサーバーとクライアントを勝手に作って、しかもHTTP/2で通信してくれる便利なフレームワークです。その一方で、HTTP REST APIにも対応しています。通信は、HTTP/2を基本とし、Javaの非同期ネットワークライブラリとして有名な<a href="https://netty.io/" target="_blank" rel="noopener noreferrer" class="">Netty</a>を使って実装されています（LINEに在籍しているNettyプロジェクトの設立者が開発しています）。Armeriaは、以下のようなマイクロサービスを構築するために必要なものが全て揃っている素晴らしいフレームワークです。</p>
<ul>
<li class="">HTTP/2を利用する場合に必要な、Client-side Load Balancing</li>
<li class="">障害が起きた際に、他のサービスが障害に巻き混まれる影響を最小限に抑える<a href="http://line.github.io/armeria/advanced-circuitbreaker.html" target="_blank" rel="noopener noreferrer" class="">Circuit Breaker</a></li>
<li class="">Swaggerのようなデバッグが簡単に行える<a href="http://line.github.io/armeria/server-docservice.html" target="_blank" rel="noopener noreferrer" class="">Documentation Service</a></li>
<li class=""><a href="https://github.com/line/armeria/pull/717" target="_blank" rel="noopener noreferrer" class="">MicrometerとPrometheusを利用した詳細なメトリック出力</a></li>
<li class=""><a href="https://line.github.io/armeria/advanced-zipkin.html" target="_blank" rel="noopener noreferrer" class="">Zipkin Integration</a></li>
<li class=""><a href="https://line.github.io/armeria/client-retrofit.html" target="_blank" rel="noopener noreferrer" class="">Retrofit Integration</a></li>
</ul>
<p>Armeriaを使うと、ThriftやgRPCを利用するサーバー・クライアントをすべて非同期化することができます。LINE Shopでは、ほぼすべてのサービスでArmeriaを利用して、サービスの基礎となるネットワーク通信部分から、その先のRPCコールまでを非同期APIで結んでいます。社内でも、Armeriaを使っているプロジェクトはまだまだ多くないのですが、これからもっと増やしていこうと、パイロットプロジェクト的なものになっています（実際にはそんなきれい事ではなくて、多数のバグや障害を率先的に踏み抜いていく役目です）。まだまだ、大規模なAPIの変更などがあったり、メトリック出力用のライブラリが突然<a href="http://metrics.dropwizard.io/" target="_blank" rel="noopener noreferrer" class="">Dropwizard Metrics</a>から<a href="https://micrometer.io/" target="_blank" rel="noopener noreferrer" class="">Micrometer</a>に変わったりしていますが、LINE Shopやその他いくつかのチームではプロダクション環境で本気で使っていますし、基本的な部分に関しては最近は安定しているので、使ってくれる仲間を募集中です。</p>
<p><img decoding="async" loading="lazy" alt="Armeria Documentation Service" src="https://armeria.dev/assets/images/asynchronous-micro-service-in-rxjava-2-armeria-5-68362bedc903d62abb81b59d536c0599.png" width="1362" height="974" class="img_ev3q"> 'Armeria Documentation Service'</p>
<p>Armeria Documentation Service</p>
<p><img decoding="async" loading="lazy" alt="Shop Grafana Dashboard" src="https://armeria.dev/assets/images/asynchronous-micro-service-in-rxjava-2-armeria-6-4f585de289046e7d4633fb83bd1f9c5f.png" width="2808" height="1790" class="img_ev3q"> 'Shop Grafana Dashboard'</p>
<p>Prometheus＋Grafanaを利用したメトリック出力</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="サーバーサイドrxjava-2">サーバーサイドRxJava 2<a href="https://armeria.dev/blog/ja/2017/12/01/asynchronous-micro-service-in-rxjava-2-armeria#%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC%E3%82%B5%E3%82%A4%E3%83%89rxjava-2" class="hash-link" aria-label="Direct link to サーバーサイドRxJava 2" title="Direct link to サーバーサイドRxJava 2" translate="no">​</a></h2>
<p>LINE Shopでは、今年の初めあたりに<a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="noopener noreferrer" class="">RxJava 2</a>を導入して、非同期APIの結果に対する処理の流れがかなりきれいに書けるようになりました。非同期APIを使って、上から下まですべてを非同期にしてしまうと、実際に内部の処理を書くコードは結構変わってきます。それまでは全てが同期的なAPIで、ただ普通の型を扱っていたコードが、突然Futureだらけになってしまうからです。そして、Futureに対して何か変換処理を行ったり、2つのFutureの結果を待ち受けて処理を行ったりするためには、特殊な操作が必要です。非同期でFutureを使うと、コードの書きやすさとしてはどうしても劣ってしまいますし、今までの手続き的な同期APIばかりを使ってプログラムを書いてきた者としては、とっつきづらいという感想もチーム内ではよくありました。非同期APIをたくさん扱うようになると、このあたりが面倒になってきて、諦める人も多いかと思います。LINE Shopでは、Reactive Streamsを採用したRxJava 2を導入することで、この煩わしさを解決しました。</p>
<p>本格的に非同期化を始めた2年半ほど前は、GuavaのListenableFutureを使っていました。.transform()や.transformAsync()といったメソッドで、Futureの結果に対して変換を行ったり、そのFutureをもとに新たなリクエストを投げるFutureに変換したりするのですが、ListenableFutureのままではなかなか扱いづらいです。Java 8は普段から利用していたので、CompletableFutureも使える状況で、こちらは.map()のような処理が簡単に行えるAPIが用意されているのですが、いろいろあってListenableFutureのままでした。<a href="http://square.github.io/dagger/" target="_blank" rel="noopener noreferrer" class="">Dagger</a>のAsync Dependency Injection を裏技的に利用したりもしていましたが、コードの可読性やデバッグのやりやすさが著しく低下するので、現在はRxJava 2に乗り換えて正解だったと思っています。</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="rxjavaを導入して得られたメリット">RxJavaを導入して得られたメリット<a href="https://armeria.dev/blog/ja/2017/12/01/asynchronous-micro-service-in-rxjava-2-armeria#rxjava%E3%82%92%E5%B0%8E%E5%85%A5%E3%81%97%E3%81%A6%E5%BE%97%E3%82%89%E3%82%8C%E3%81%9F%E3%83%A1%E3%83%AA%E3%83%83%E3%83%88" class="hash-link" aria-label="Direct link to RxJavaを導入して得られたメリット" title="Direct link to RxJavaを導入して得られたメリット" translate="no">​</a></h3>
<p>RxJavaというより、Reactive Streamsを採用することで得られた恩恵は、非同期APIに対するデータの処理が簡潔に書けるようになったことと、データの流れを意識しながらプログラムを書けるようになったことです。例えば、従来のFutureでは.transform()を利用して、ネストして書いていたものが、RxJavaではmapを使って簡潔に書けるようになります。これが、複数の非同期APIの結果を利用して、また別の非同期APIを呼び出すような場合に、.flatMap()を使って気軽に行えるあたりはとても気持ち良いです。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// Service AからProductを複数取得</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// ProductごとにTag idを利用してService Bにリクエスト</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Tagを取得したらProductにセット</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// ProductのListを返す</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">serviceA.getProducts()             // Single&lt;List&lt;Product&gt;&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .filter(p -&gt; p.isOnSale())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .flattenAsFlowable()       // Flowable&lt;Product&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .flatMap(p -&gt; serviceB.getTag(p.getTagId()) // Single&lt;Tag&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                              .map(tag -&gt; p.setTag(tag)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .toList()                  // Single&lt;List&lt;Product&gt;&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .doOnError(e -&gt; log.error("ERROR!"));</span><br></span></code></pre></div></div>
<p>ListenableFutureやCompletableFutureを使っているライブラリでも、簡単にRxJava 2に変換できるように、それらを変換するライブラリを作ったり利用したりして、あまり細かいことは気にせずにReactive Streamsに変換できるような環境を整えています（例えば、<a href="https://github.com/akarnokd/RxJava2Jdk8Interop" target="_blank" rel="noopener noreferrer" class="">RxJava2Jdk8Interop</a>など）。実際は、非同期処理が発火されるタイミングが、FutureとRxJavaでは根本的に考え方が違うのですが、このあたりはあまり気にせずに利用できるようにしています。</p>
<p>また、データの流れを意識して、Reactiveに書けるという点も、コードを書いていてとても気持ちよくなる点の1つです。今までは手続き的にいろんな変数にぐちゃぐちゃと一時的なデータを入れ込んで、見通しが悪いプログラムを書きがちだったものが、データが非同期的に集まってきて、Reactive Streamsの中できれいに書こうとすると、自ずとデータの流れを意識した効率的なプログラムになります。今書いているコードにどんなデータが必要で、どこからデータが来て、何に変換されていくか、という流れが、自然に明確になる感じがあります。</p>
<p>このようなデータフローを意識していくと、無駄な処理や、イケていないコードや設計が駆逐されていきます（正確に言うと、データの流れに反するようなコードをReactive Streamsの上で書くのが難しいので、書きたくなくなります）。これは、直接非同期化とは関係ない事ではありますが、RxJavaを使うことで現れた良い副作用の1つですね。ただし、RxJavaを使いこなすためには若干学習が必要なのと、関数型言語やReactiveな世界に触れたことがない手続き型バリバリの頭だと、最初は厳しいこともあると思うので、導入する際にはチームメンバーの教育と協力が必要だと思います。</p>
<p>その他にも、RxJavaを採用して得られたメリットや落とし穴など、詳しくは福岡オフィスの同じチームのメンバーである@kojilinさんがJJUG CCCで話した内容に詳しく解説されているので、こちらをぜひご覧ください。</p>
<p>サーバーサイドでの非同期処理で色々やったよ<a href="https://docs.google.com/presentation/d/1LKcFzspXUQbq-sivRBPb3Q6V7fQBLKB0zH6BSnGrD%5C_I/edit#slide=id.p" target="_blank" rel="noopener noreferrer" class="">https://docs.google.com/presentation/d/1LKcFzspXUQbq-sivRBPb3Q6V7fQBLKB0zH6BSnGrD\_I/edit#slide=id.p</a></p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="今後の課題">今後の課題<a href="https://armeria.dev/blog/ja/2017/12/01/asynchronous-micro-service-in-rxjava-2-armeria#%E4%BB%8A%E5%BE%8C%E3%81%AE%E8%AA%B2%E9%A1%8C" class="hash-link" aria-label="Direct link to 今後の課題" title="Direct link to 今後の課題" translate="no">​</a></h2>
<p>今後の課題には、以下のようなものがあります。</p>
<ul>
<li class="">MySQL（JDBC）には、非同期APIが存在しない</li>
<li class="">同期的なAPIと非同期的なAPIが混ざることによりミスが発生する</li>
<li class="">新しいメンバーに対する、非同期とはなにか、非同期の場合にはこうするべき、というような知識の移譲</li>
</ul>
<p>まずは、1つ目のMySQLの問題です。LINE ShopではMyBatisと組み合わせてMySQLを利用しているのですが、仕方なくThreadPoolExecutorを使って、Futureに変換しています。また、MySQLはスタンプ（Sticker）関連の処理でしか利用していないので、さまざまなリクエストが集まるサーバーではなく、スタンプ専用のMySQLが必要なリクエストを処理するサーバーに処理をまとめることで、問題を回避しています。将来的に、非同期的なJDBCが実装され利用できるようになれば、この問題も解決されることでしょう。</p>
<p>同期的なAPIと非同期的なAPIが混ざることによるミスというのは、非同期を実現するために利用しているイベントループの根本的な仕組みではあるのですが、イベントループは少ない数のスレッドで実現されているために、その中ではCPUをブロックしてしまうような処理を実行することは許されません。つまり、ArmeriaやNettyなどイベントループを利用するライブラリでは、リクエストを受け付けてAPIのハンドラを実行する関数は通常イベントループ上で実行されるため、その中で同期的なAPIリクエストを行うことはできません。同期的なAPIをイベントループ内で呼んでしまうと、著しいパフォーマンスの低下やデッドロックを引き起こします。</p>
<p>しかし、ミスはつきもので、今までの感覚でついつい同期的なAPIを呼びたくなってしまうこともあるし、コードレビューで見抜けないこともあります。なので、同期的なAPIを利用する関数を完全に撤廃するべきなのですが、同期APIから非同期APIに移行するとき、すべてを一気に移行するのは難しいです。</p>
<p>3番目の課題につながることですが、非同期APIについてチーム内で理解を深めあって、やってはいけないことの共有をコードレビューなどを通じてしっかり行いながら、共通認識を持つのが大事だと思います。</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="まとめ">まとめ<a href="https://armeria.dev/blog/ja/2017/12/01/asynchronous-micro-service-in-rxjava-2-armeria#%E3%81%BE%E3%81%A8%E3%82%81" class="hash-link" aria-label="Direct link to まとめ" title="Direct link to まとめ" translate="no">​</a></h2>
<p>この記事のまとめですが、言いたかったことはだいたい以下のようなものです。</p>
<ul>
<li class="">RPCやDBアクセスが沢山発生するAPIで、スレッドプールを使って並列化する場合、スレッドプールの限界を考える必要があります。</li>
<li class="">同期的なAPIだと何をやってもリクエストしている間にスレッドを専有してしまうので、非同期APIを使うと効率的です。</li>
<li class="">LINEでは、ThriftとgRPCを扱える、HTTP/2に対応した非同期RPCフレームワーク<a href="http://line.github.io/armeria/" target="_blank" rel="noopener noreferrer" class="">Armeria</a>を開発しています。</li>
<li class="">RxJavaを使うと、RPCやDBアクセスを非同期的にした場合でも、Reactiveにデータの流れを考えながらきれいなコードが書けます。</li>
</ul>
<p>結果的に、LINE Shopでの1台のサーバーあたりで捌いているAPIリクエスト数について言えば、APIの内容にもよりますが、物理サーバー1台あたり最大毎秒3,000件程度のリクエストを受けて、毎秒10,000件程度のRPC、Redis、DBリクエストを発行するような、高トラフィックな状況を耐え凌いだこともあります。スタンプメッセージのバリデーションを行うようなサーバーは、常時毎秒数千リクエストを捌くことができています。</p>
<p>実際には、非同期APIを利用するだけでなく、RPCを少なくするような仕組みや、キャッシュを行うサーバーを限定したり、<a href="https://github.com/ben-manes/caffeine/wiki" target="_blank" rel="noopener noreferrer" class="">Caffeine</a>を使ったローカルメモリキャッシュを併用したりしつつ、いろいろな工夫をして意外と少ないサーバー数で運用しています。実際には、APIによってはまだまだ無駄なことをしている部分があったり、ベンチマークをきちんとできているとはいえないので、今の構成でもさらに詰めるべき点はあると思っています。さらに、ほとんどのAPIは100ms以内に結果を返すことができていて、私達のチームでは、APIのレスポンスが95パーセンタイルで1秒を超えていたら、好ましくない状況だという共通認識で運用をしています。</p>
<p>雑多な紹介になってしまいましたが、非同期APIの必要性と面白さをおわかりいただけたでしょうか？最後になりますが、非同期RPCフレームワーク<a href="http://line.github.io/armeria/" target="_blank" rel="noopener noreferrer" class="">Armeria</a>をよろしくお願いします。</p>
<p>明日の記事はSongran Liuさんによる「<a href="https://engineering.linecorp.com/ja/blog/detail/214" target="_blank" rel="noopener noreferrer" class="">LINE Developersサイトを支えるDAO自動生成ツール</a>」です。お楽しみに！</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[チャネルゲートウェイへのCircuitBreakerの適用]]></title>
            <link>https://armeria.dev/blog/ja/2016/08/04/applying-circuitbreaker-to-channel-gateway</link>
            <guid>https://armeria.dev/blog/ja/2016/08/04/applying-circuitbreaker-to-channel-gateway</guid>
            <pubDate>Thu, 04 Aug 2016 00:00:00 GMT</pubDate>
            <description><![CDATA[はじめに]]></description>
            <content:encoded><![CDATA[<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="はじめに">はじめに<a href="https://armeria.dev/blog/ja/2016/08/04/applying-circuitbreaker-to-channel-gateway#%E3%81%AF%E3%81%98%E3%82%81%E3%81%AB" class="hash-link" aria-label="Direct link to はじめに" title="Direct link to はじめに" translate="no">​</a></h2>
<p><a class="" href="https://armeria.dev/blog/ja/2016/07/14/circuit-breakers-for-distributed-services">Circuit Breakerの紹介記事</a>を先に読むことを推奨します。</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="チャネルゲートウェイにcircuitbreakerを適用する">チャネルゲートウェイにCircuitBreakerを適用する<a href="https://armeria.dev/blog/ja/2016/08/04/applying-circuitbreaker-to-channel-gateway#%E3%83%81%E3%83%A3%E3%83%8D%E3%83%AB%E3%82%B2%E3%83%BC%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A4%E3%81%ABcircuitbreaker%E3%82%92%E9%81%A9%E7%94%A8%E3%81%99%E3%82%8B" class="hash-link" aria-label="Direct link to チャネルゲートウェイにCircuitBreakerを適用する" title="Direct link to チャネルゲートウェイにCircuitBreakerを適用する" translate="no">​</a></h2>
<p>チャネルゲートウェイサーバは、LINEの多様なサーバの機能をCP(Contents Provider)に提供する役割を担っています。そのため、チャネルゲートウェイサーバは接続されているサーバに大きく影響されます。なお、そうした影響はチャネルゲートウェイサーバ全体に容易に拡散します。</p>
<p><img decoding="async" loading="lazy" src="https://armeria.dev/assets/images/applying-circuitbreaker-to-channel-gateway-1-537a3aa178c1835906c7a42d541dac55.png" width="870" height="328" class="img_ev3q"></p>
<!-- -->
<p>この問題の解決に悩んでいたところ、CircuitBreakerに関する内容を聞きました。特定のサーバに障害が発生した場合、CircuitBreakerがそれを検知してそのサーバに投げられるリクエストを遮断すれば、問題を十分解決できると思いました。そのため、チャネルゲートウェイにCircuitBreakerを適用することを決めました。</p>
<p>チャネルゲートウェイ用のCircuitBreakerを直接実装することもできましたが、<a href="http://line.github.io/armeria/" target="_blank" rel="noopener noreferrer" class="">Armeria</a>にすでに見事なCircuit Breakerが実装されていました。ArmeriaのCircuitBreakerは、様々なオプションをニーズに合わせて設定し、<code>CircuitBreakerBuilder</code>で実装されたCircuitBreakerオブジェクトを得ることができます。このオブジェクトによってチャネルゲートウェイに合わせてカスタマイズできるようになっているので、簡単に適用することができました。</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="circuitbreakerのアノテーションの使用">CircuitBreakerのアノテーションの使用<a href="https://armeria.dev/blog/ja/2016/08/04/applying-circuitbreaker-to-channel-gateway#circuitbreaker%E3%81%AE%E3%82%A2%E3%83%8E%E3%83%86%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AE%E4%BD%BF%E7%94%A8" class="hash-link" aria-label="Direct link to CircuitBreakerのアノテーションの使用" title="Direct link to CircuitBreakerのアノテーションの使用" translate="no">​</a></h2>
<p>talk-channel-gatewayソースコードにおいてCircuitBreakerは、<code>@CircuitBreakable</code>アノテーションを使用して適用できます。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">@CircuitBreakable(CircuitBreakerGroup.HBASE_CLIENT_USER_SETTINGS)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public ChannelSettings findBy(String mid) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>上記のように適用した場合、<code>findBy()</code>メソッドが呼び出される度に成功/失敗を監視し、その結果によってCircuitBreakerが開閉します。HBASE_CLIENT_USER_SETTINGSはCircuitBreakerで束ねるグループを指定するもので、各メソッドの失敗率を計算する際もグループ全体の呼び出し回数に対する失敗回数で計算し、CircuitBreakerの開閉時も一緒に開閉します。</p>
<p>CircuitBreakerの設定は、<code>CircuitBreakerGroup</code>というenumオブジェクトで次のように設定できます。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public enum CircuitBreakerGroup implements ExceptionFilter {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    SAMPLE_DEFAULT {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    SAMPLE_API {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        protected ExceptionFilter exceptionFilter() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return cause -&gt; !(cause instanceof AuthenticationException</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                              || cause instanceof ApiPermissionException</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                              || cause instanceof ImproperRequestException);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    HBASE_CLIENT_CHANNEL_MATRIX {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    HBASE_CLIENT_USER_SETTINGS {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected ExceptionFilter exceptionFilter() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return cause -&gt; true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public CircuitBreaker circuitBreaker(CircuitBreakerListener listener) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new `CircuitBreakerBuilder`(name()).exceptionFilter(exceptionFilter())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                .listener(listener)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                .build();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public boolean shouldDealWith(Throwable throwable) throws Exception {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return exceptionFilter().shouldDealWith(throwable);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>チャネルゲートウェイでは<code>ExceptionFilter</code>をカスタマイズして使用しました。それ以外のオプションは、Armeriaのデフォルトオプションをそのまま使用しました。もし、他のオプションを変更して使いたい場合は、<code>circuitBreaker()</code>メソッドを修正して使用できるでしょう。</p>
<p>Armeriaでは、どんなものであってもExceptionが発生した場合は基本的に失敗とみなすようになっています。しかし、チャネルゲートウェイでは、権限がない場合などをExceptionとして処理して返すので、それを区分する必要がありました。そのため、<code>ExceptionFilter</code>をカスタマイズして使用しました。そして、CircuitBreakerのステータスが変わる度にログを蓄積できるように、チャネルゲートウェイのためのListenerも追加しました。</p>
<p>アノテーションに適用するグループはenumオブジェクトで指定でき、enumオブジェクトを実装部においてグループごとに設定を変えられるようにしました。</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="circuitbreakerにおけるproceedの実装">CircuitBreakerにおけるproceed()の実装<a href="https://armeria.dev/blog/ja/2016/08/04/applying-circuitbreaker-to-channel-gateway#circuitbreaker%E3%81%AB%E3%81%8A%E3%81%91%E3%82%8Bproceed%E3%81%AE%E5%AE%9F%E8%A3%85" class="hash-link" aria-label="Direct link to CircuitBreakerにおけるproceed()の実装" title="Direct link to CircuitBreakerにおけるproceed()の実装" translate="no">​</a></h2>
<p><a href="https://en.wikipedia.org/wiki/AspectJ" target="_blank" rel="noopener noreferrer" class="">Aspect</a> オブジェクトの<code>proceed()</code>コードは以下のとおりです。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class CircuitBreakerAspect implements Ordered {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final Map&amp;lt;CircuitBreakerGroup, CircuitBreaker&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    circuitBreakers = new EnumMap&amp;lt;&gt;(CircuitBreakerGroup.class);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @PostConstruct</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void initialize() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final CircuitBreakerListener listener = new</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        CircuitBreakerListenerImpl(circuitBreakerLogger);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (CircuitBreakerGroup group : CircuitBreakerGroup.values()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            circuitBreakers.put(group, group.circuitBreaker(listener));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Object proceed(final ProceedingJoinPoint pjp, final CircuitBreakable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    circuitBreakable) throws Throwable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final CircuitBreakerGroup group = circuitBreakable.value();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final CircuitBreaker circuitBreaker = circuitBreakers.get(group);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (circuitBreaker.canRequest()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            final Object result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                result = pjp.proceed();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (Throwable e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (group.shouldDealWith(e)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    circuitBreaker.onFailure(e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    circuitBreaker.onSuccess();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                throw e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            circuitBreaker.onSuccess();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw CircuitBreakerException.circuitBroken();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>コードは比較的に簡単です。<code>CircuitBreaker.canRequest()</code>によってCircuitBreakerが開放されている場合は、Exceptionを発生させます。そうでない場合は、メソッドを正常に呼び出します。呼び出した結果Exceptionが発生し、そのExceptionを失敗として処理すべき場合は、CircuitBreakerに失敗したと知らせます。そうでない場合は、CircuitBreakerに成功したと知らせるだけで済みます。</p>
<p>ちなみに、実際に適用したコードにはCircuitBreakerが正しく適用されたかどうかを確認するためにIMON Logger※注と関連するコードが入っています。しかし、ここではCircuitBreaker部分に集中できるように省略しました。</p>
<p>※注：IMONは、社内の多様なサービスをモニタリングするためのシステムです。IMON Loggerは、対象サービスの統計指標とログを取りまとめてIMONに送る機能を果たしています。</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="circuitbreakerの設定変更メソッド">CircuitBreakerの設定変更メソッド<a href="https://armeria.dev/blog/ja/2016/08/04/applying-circuitbreaker-to-channel-gateway#circuitbreaker%E3%81%AE%E8%A8%AD%E5%AE%9A%E5%A4%89%E6%9B%B4%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89" class="hash-link" aria-label="Direct link to CircuitBreakerの設定変更メソッド" title="Direct link to CircuitBreakerの設定変更メソッド" translate="no">​</a></h2>
<p>CircuitBreakerオブジェクトを作ってくれる<code>CircuitBreakerBuilder</code>は、CircuitBreakerの設定を変更できる様々なメソッドを提供しています。なるべくデフォルトの設定をそのまま使用することを推奨しますが、CircuitBreakerの設定について、もっと分かりやすく説明しておきたいと思います。</p>
<table><thead><tr><th>Method</th><th>Parameter</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td>failureRateThreshold</td><td>double</td><td>0.8</td><td>CircuitBreakerの開閉を判断する際に使用するための失敗率です。<code>counterSlidingWindow</code>期間中の失敗率がこの値を上回る場合はCircuitBreakerが開放されます。デフォルト値をそのまま使用する場合、80%以上失敗するとCircuitBreakerが開放されます。つまり、成功率が20%未満ならCircuitBreakerが開放されるわけです。</td></tr><tr><td>minimumRequestThreshold</td><td>long</td><td>10</td><td>CircuitBreakerを開閉を判断するための最低呼び出し回数です。<code>counterSlidingWindow</code>期間中の呼び出し回数がこの値を下回る場合は CircuitBreakerの開閉を判断しません。</td></tr><tr><td>circuitOpenWindow</td><td>Duration</td><td>10 seconds</td><td>CircuitBreakerがOpen状態になってからHalf-Open状態に変わるまでの時間です。CircuitBreakerの開放後は、<code>circuitOpenWindow</code>期間だけの時間が過ぎてからHalf-Open状態に変わり、リクエストをテストします。</td></tr><tr><td>circuitOpenWindowMillis</td><td>long</td><td>10000</td><td></td></tr><tr><td>trialRequestInterval</td><td>Duration</td><td>3 seconds</td><td>Half-Open状態で投げたリクエストがClosed応答を返さなかった場合、リクエストをリトライするための待ち時間です。<code>trialRequestInterval</code>時間以内に応答が返ってきた場合は、その結果によってClosedまたはOpen状態に変わります。もし、Open状態になった場合は、再度<code>circuitOpenWindow</code>期間だけ待機してからリクエストをテストします。しかし、投げたリクエストが<code>trialRequestInterval</code>期間中に何も応答も返さなかった場合、リクエストをリトライします。</td></tr><tr><td>trialRequestIntervalMillis</td><td>long</td><td>3000</td><td></td></tr><tr><td>counterSlidingWindow</td><td>Duration</td><td>20 seconds</td><td>CircuitBreakerの開閉を判断する際、最近の<code>counterSlidingWindow</code>期間分の記録をもって判断します。デフォルト値をそのまま使用すれば、ここ20秒間のリクエスト結果だけで判断するようになります。</td></tr><tr><td>counterSlidingWindowMillis</td><td>long</td><td>20000</td><td></td></tr><tr><td>counterUpdateInterval</td><td>Duration</td><td>1 second</td><td>CircuitBreakerでは、リクエストの結果を<code>SlidingWindowCounter</code>によって保管していますが、ここで保管する単位となる時間を意味します。デフォルト値をそのまま使用すると、1秒単位で記録を保持します。例えば、ここ20秒前=成功20回、失敗0回 / ここ19秒前=成功25回、失敗1回 / … / ここ1秒前=成功21回、失敗0回などの記録を保持します。この1秒単位の記録で<code>counterSlidingWindow</code>期間分を計算し、失敗率を出します。</td></tr><tr><td>counterUpdateIntervalMillis</td><td>long</td><td>1000</td><td></td></tr><tr><td>exceptionFilter</td><td>ExceptionFilter</td><td>すべてのExceptionを失敗としてみなす</td><td>Exceptionが発生した場合、そのExceptionを失敗としてみなすかどうかを返すオブジェクトです。デフォルト値をそのまま使用すれば、すべてのExceptionを失敗とみなします。</td></tr><tr><td>listener</td><td>CircuitBreakerListener</td><td></td><td>CircuitBreakerのStateが変わった場合、<code>counterUpdateInterval</code>の時間が過ぎた場合、CircuitBreakerが開放されてリクエストがリジェクトされた場合に対するイベントを受信できるListenerです。</td></tr></tbody></table>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="まとめ">まとめ<a href="https://armeria.dev/blog/ja/2016/08/04/applying-circuitbreaker-to-channel-gateway#%E3%81%BE%E3%81%A8%E3%82%81" class="hash-link" aria-label="Direct link to まとめ" title="Direct link to まとめ" translate="no">​</a></h2>
<p>これまでは、チャネルゲートウェイの一部で障害が発生すると、対応する前にすでに大きな被害が出ていました。一部で発生した障害がThread Full現象をまねき、結局はサービス全体に影響を与えたためです。しかし、これからはCircuitBreakerがそのような部分を遮断してくれるので、より余裕を持って対応できるようになるでしょう。</p>
<p>最後に、上述の設定を利用してCircuitBreakerの動作方法を説明します。</p>
<ul>
<li class="">CircuitBreakerの初期状態は<em>Closed</em>です。</li>
<li class=""><em>Closed</em> : リクエストを遂行した後、<code>ExceptionFilter</code>によって次のように動作します。<!-- -->
<ul>
<li class="">結果が成功なら、成功したという記録を残し、<em>Closed</em>状態に変わります。</li>
<li class="">結果が失敗なら、<code>counterSlidingWindow</code>期間分のリクエスト結果を確認して<!-- -->
<ul>
<li class="">minimumRequestThreshold数より多く、失敗率がfailureRateThreshold以上であれば、<em>Open</em>状態に変わります。</li>
<li class="">そうでない場合は、Closed状態が維持されます。</li>
</ul>
</li>
</ul>
</li>
<li class=""><em>Open</em> : <code>circuitOpenWindow</code>期間が過ぎれば、<em>Half-Open</em>状態に変わります。</li>
<li class=""><em>Half-Open</em> : 最初に入ってくるリクエストを遂行した後、<code>ExceptionFilter</code>によって次のように動作します。<!-- -->
<ul>
<li class="">結果が成功なら、<em>Closed</em>状態に変わります。</li>
<li class="">結果が成功なら、<em>Open</em>状態に変わります。</li>
<li class=""><code>trialRequestInterval</code>の時間以内に応答がなければ、<em>Half-Open</em>状態でその次に入ってくる最初のリクエストの結果によって分岐処理します。</li>
</ul>
</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="作成者の紹介">作成者の紹介<a href="https://armeria.dev/blog/ja/2016/08/04/applying-circuitbreaker-to-channel-gateway#%E4%BD%9C%E6%88%90%E8%80%85%E3%81%AE%E7%B4%B9%E4%BB%8B" class="hash-link" aria-label="Direct link to 作成者の紹介" title="Direct link to 作成者の紹介" translate="no">​</a></h2>
<p>Shin Jong Hun：面倒なことが大嫌いで、面倒を減らすために悩み続けています。これがプログラミングが好きになった理由なのですが、なんだかやることが増えた気がするのは自分だけでしょうかね？</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[分散サービス環境へのCircuit Breakerの適用]]></title>
            <link>https://armeria.dev/blog/ja/2016/07/14/circuit-breakers-for-distributed-services</link>
            <guid>https://armeria.dev/blog/ja/2016/07/14/circuit-breakers-for-distributed-services</guid>
            <pubDate>Thu, 14 Jul 2016 00:00:00 GMT</pubDate>
            <description><![CDATA[LINEエンジニアのonoです。この記事では、LINEのサーバで実際に導入を始めているCircuit Breakerという仕組みについてご紹介します。]]></description>
            <content:encoded><![CDATA[<p>LINEエンジニアのonoです。この記事では、LINEのサーバで実際に導入を始めている<code>Circuit Breaker</code>という仕組みについてご紹介します。</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="circuit-breakerとは">Circuit Breakerとは？<a href="https://armeria.dev/blog/ja/2016/07/14/circuit-breakers-for-distributed-services#circuit-breaker%E3%81%A8%E3%81%AF" class="hash-link" aria-label="Direct link to Circuit Breakerとは？" title="Direct link to Circuit Breakerとは？" translate="no">​</a></h2>
<p>LINEをはじめとする昨今のWebやアプリのバックエンドサーバシステムは、お互いにAPIやRPCで接続された多数のサービスのネットワークとして構成されるようになってきました。</p>
<p>もしこのネットワークの中の1つが突然全く応答を返さなくなったらどうなるでしょうか？ ダウンしたサービスに対するアクセスがタイムアウトするまでブロックすることにより、依存するサービスまでもが連鎖的にダウンしてしまう可能性があります。 もしネットワークの全容を誰も把握できていなかったら、根本の原因がどのサービスにあるのか発見するのに時間がかかってしまうでしょう。</p>
<p><img decoding="async" loading="lazy" alt="-BG-" src="https://armeria.dev/assets/images/circuit-breakers-for-distributed-services-1-5bb7df69bbea59e475a05522088cd493.png" width="537" height="141" class="img_ev3q"></p>
<!-- -->
<p>我々はこのような障害の連鎖を防がなくてはいけません。少なくとも、最も重要な機能が影響を受けないようにする必要があります。 そのためには、障害がおきたサービスへのアクセスを遮断しなければなりません。</p>
<p><img decoding="async" loading="lazy" alt="-BG-" src="https://armeria.dev/assets/images/circuit-breakers-for-distributed-services-2-94100185efcea1b197617840a9c6a288.png" width="537" height="140" class="img_ev3q"></p>
<p>この仕組みを自動化したものが、Circuit Breakerです。 <a href="http://martinfowler.com/bliki/CircuitBreaker.html" target="_blank" rel="noopener noreferrer" class="">http://martinfowler.com/bliki/CircuitBreaker.html</a></p>
<p>上のMartin Fowler氏の記事が詳しいですが、ここで簡単に説明します。<br>
<!-- -->Circuit Breakerとは、リモートアクセスの成功／失敗をカウントし、 エラー率(failure rate)が閾値を超えたときに自動的にアクセスを遮断する仕組みです。<br>
<!-- -->Circuit Breakerはステートマシンとして表現できます。 アクセス成功や失敗といったイベントが発生するたびに内部状態を更新し、障害の検出と復旧の判断を自動的に行います。</p>
<p><img decoding="async" loading="lazy" src="https://armeria.dev/assets/images/circuit-breakers-for-distributed-services-3-706b943b1852878bf1209d68ac7ca623.png" width="749" height="182" class="img_ev3q"></p>
<p>それぞれの状態と遷移の条件は以下の通りです。<br>
<strong>CLOSED</strong><br>
<!-- -->初期状態です。全てのアクセスは普通に実行されます。<br>
<strong>OPEN</strong><br>
<!-- -->エラー率が閾値を超えるとOPEN状態になります。全てのアクセスは遮断（fail fast）されます。<br>
<strong>HALF_OPEN</strong><br>
<!-- -->OPENから一定時間たつとHALF_OPEN状態になります。アクセスを試行し、成功するとCLOSED、失敗するとOPENに戻ります。</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="circuit-breaker-for-armeria">Circuit Breaker for Armeria<a href="https://armeria.dev/blog/ja/2016/07/14/circuit-breakers-for-distributed-services#circuit-breaker-for-armeria" class="hash-link" aria-label="Direct link to Circuit Breaker for Armeria" title="Direct link to Circuit Breaker for Armeria" translate="no">​</a></h2>
<p><a href="http://line.github.io/armeria/" target="_blank" rel="noopener noreferrer" class="">Armeria</a>はLINEがオープンソースとして公開している、Nettyベースの非同期Thriftクライアント/サーバライブラリです。Armeriaの素晴らしいところは、decoratorによって機能を簡単に拡張できる点です。<br>
<!-- -->そしてArmeria 0.13.0より、Circuit Breakerをdecoratorとして追加できるようになりました。 Circuit Breakerを使ったThrift Clientの初期化は次のようになります。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Iface helloClient = new ClientBuilder("tbinary+http://127.0.0.1:8080/hello")</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                     .decorator(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                      CircuitBreakerClient.newDecorator(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                          new CircuitBreakerBuilder("hello").build()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                      )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                     )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                     .build(Iface.class);</span><br></span></code></pre></div></div>
<p>簡単ですね。<br>
<!-- -->そして、このThrift Clientを呼び出すコードは次のようになります。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    helloClient.hello("line");</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} catch (TException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // error handling</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} catch (FailFastException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   // fallback code</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>Circuit Breakerが障害を検知すると、Thrift ClientはFailFastExceptionを投げるので、適切なフォールバックコードを実行します。<br>
<!-- -->非同期Clientの場合も同様です。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">helloClient.hello("line", new AsyncMethodCallback() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  public void onComplete(Object response) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     // response handling</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  public void onError(Exception e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     if (e instanceof TException) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         // error handling</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     } else if (e instanceof FailFastException) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         // fallback code</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">});</span><br></span></code></pre></div></div>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="grouping">Grouping<a href="https://armeria.dev/blog/ja/2016/07/14/circuit-breakers-for-distributed-services#grouping" class="hash-link" aria-label="Direct link to Grouping" title="Direct link to Grouping" translate="no">​</a></h2>
<p>上の例では、ひとつのThriftサービスに対してひとつのCircuit Breakerを割り当てています。この場合、同じサービスのうちのひとつのメソッドが原因でCircuitが遮断されたとき、他の全てのメソッドも遮断されてしまうことになります。これはかえって障害の影響が広がってしまうことになるため、望ましい動作ではありません。</p>
<p>そのためArmeriaでは、Circuit Breakerのインスタンスを割り当てるスコープを選択することができる、グルーピング機能を提供しています。</p>
<p>グルーピングには、以下の3種類があります。<br>
<strong>Per Method</strong><br>
<!-- -->メソッドごとにひとつのCircuit Breakerを割り当てる<br>
<strong>Per Host</strong><br>
<!-- -->リモートホストごとにひとつのCircuit Breakerを割り当てる<br>
<strong>Per Host and Method</strong><br>
<!-- -->リモートホストとメソッドごとにひとつのcircuit Breakerを割り当てる</p>
<p><img decoding="async" loading="lazy" alt="-BG-" src="https://armeria.dev/assets/images/circuit-breakers-for-distributed-services-4-4ae96ba1d797e52c0fc3b3f1f3909775.png" width="684" height="279" class="img_ev3q"></p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="failure-rate">Failure Rate<a href="https://armeria.dev/blog/ja/2016/07/14/circuit-breakers-for-distributed-services#failure-rate" class="hash-link" aria-label="Direct link to Failure Rate" title="Direct link to Failure Rate" translate="no">​</a></h2>
<p>Circuit Breakerを運用する際には、障害状態とみなす条件を明確に定義する必要があります。<br>
<!-- -->Armeriaでは、一定時間内に処理したリクエストのうち、エラー率(Failure Rate)が&lt; Failure Rate Threshold &gt;以上になった場合を障害状態として扱います。</p>
<p>ただし、リクエストがあまりにも少ない場合（起動直後の過渡状態など）は、エラー率が安定せず、障害を誤検知してしまう可能性があります。そこでリクエスト数が&lt; Minimum Request Threshold &gt;以下の場合は障害の判定を行わないように設定できます。<br>
<!-- -->そして、エラー比率をカウントする時間の長さは&lt; Sliding Window &gt;で設定します。</p>
<p>Failure RateとSliding Windowの関係は以下の図で表されます。</p>
<p><img decoding="async" loading="lazy" alt="-BG-" src="https://armeria.dev/assets/images/circuit-breakers-for-distributed-services-5-2ff3131f0701105e189fa5953d2d9c1e.png" width="585" height="277" class="img_ev3q"></p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="monitoring">Monitoring<a href="https://armeria.dev/blog/ja/2016/07/14/circuit-breakers-for-distributed-services#monitoring" class="hash-link" aria-label="Direct link to Monitoring" title="Direct link to Monitoring" translate="no">​</a></h2>
<p>Circuit Breaker Listenerにより、Circuit Breakerの状態変化をモニタリングすることができます。</p>
<p>下のコードは、Armeriaが提供するDropwizard MetricsベースのListenerを使用する例です。 もちろんカスタムのモニタリングシステムに合わせたListenerを実装することもできます。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MetricRegistry registry = new MetricRegistry();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Iface helloClient = new ClientBuilder("tbinary+http://127.0.0.1:8080/hello")</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       .decorator(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        CircuitBreakerClient.newDecorator(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          new CircuitBreakerBuilder("hello")</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .listener(new DropwizardMetricsCircuitBreakerListener(registry, "hello"))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .build()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       .build(Iface.class);</span><br></span></code></pre></div></div>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="armeriaのcircuit-breakerを単体で使う">ArmeriaのCircuit Breakerを単体で使う<a href="https://armeria.dev/blog/ja/2016/07/14/circuit-breakers-for-distributed-services#armeria%E3%81%AEcircuit-breaker%E3%82%92%E5%8D%98%E4%BD%93%E3%81%A7%E4%BD%BF%E3%81%86" class="hash-link" aria-label="Direct link to ArmeriaのCircuit Breakerを単体で使う" title="Direct link to ArmeriaのCircuit Breakerを単体で使う" translate="no">​</a></h2>
<p>ここまでは、ArmeriaのThrift ClientとCircuit Breakerパッケージを組み合わせて使う方法を紹介しましたが、 Circuit Breakerパッケージを単体で利用することもできます。</p>
<p>Circuit Breakerパッケージを単体で使う場合、重要なAPIは以下の３つだけです。<br>
<strong>CircuitBreaker#canRequest()</strong><br>
<!-- -->Circuit Breakerの状態を確認します。Circuitが遮断されている場合は false を返します。<br>
<strong>CircuitBreaker#onSuccess()</strong><br>
<!-- -->サービスへのアクセスが正常に行われたことを記録します。<br>
<strong>CircuitBreaker#onFailure()<strong>または</strong>CircuitBreaker#onFailure(Throwable t)</strong><br>
<!-- -->サービスへのアクセスが失敗したことを記録します。</p>
<p>以下のサンプルコードでは、まずcanRequest()によってCircuitの状況を確認し、問題がない場合はremote service accessを実行します。そしてその結果によって、onSuccessかonFailureを呼び出しています。</p>
<p>ここでは例外が発生したかどうかを結果の条件としていますが、この条件は状況に合わせて自由に定義できます。例えば、remote service accessが一定時間以上掛かった場合は、例外が発生していなくてもエラーとしてカウントするといったことも可能です。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">if (circuitBreaker.canRequest()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       // remote service access</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       circuitBreaker.onSuccess();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   } catch (Exception e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       circuitBreaker.onFailure(e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   // fail fast</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>以上、ArmeriaのCircuit Breaker機能について紹介いたしました。</p>
<p>LINEにおける実際の事例については、次の機会にご紹介できればと思います。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[社内プロジェクト「Armeria」をオープンソース化するために行った６つのステップ]]></title>
            <link>https://armeria.dev/blog/ja/2016/04/13/open-sourcing-armeria</link>
            <guid>https://armeria.dev/blog/ja/2016/04/13/open-sourcing-armeria</guid>
            <pubDate>Wed, 13 Apr 2016 00:00:00 GMT</pubDate>
            <description><![CDATA[Armeriaは、Java 8およびNetty上に非同期RPC/APIクライアントサーバを実装したものです。LINEは昨年11月、ArmeriaをApache License 2.0のもと、オープンソースとして公開しました。Armeriaは、HTTP/2をセッションレイヤプロトコルとして使用する高性能の非同期Thriftクライアントサーバを構築するために立ち上げたプロジェクトですが、基本的にプロトコル非依存型で拡張性に優れています(例えば、HTTP/2によって静的ファイルを処理すると同時に、Java EE Webアプリケーションを起動することができます)。]]></description>
            <content:encoded><![CDATA[<p><a href="http://line.github.io/armeria/" target="_blank" rel="noopener noreferrer" class="">Armeria</a>は、Java 8および<a href="http://netty.io/" target="_blank" rel="noopener noreferrer" class="">Netty</a>上に非同期RPC/APIクライアントサーバを実装したものです。LINEは昨年11月、ArmeriaをApache License 2.0のもと、オープンソースとして公開しました。Armeriaは、HTTP/2をセッションレイヤプロトコルとして使用する高性能の非同期Thriftクライアントサーバを構築するために立ち上げたプロジェクトですが、基本的にプロトコル非依存型で拡張性に優れています(例えば、HTTP/2によって静的ファイルを処理すると同時に、Java EE Webアプリケーションを起動することができます)。</p>
<!-- -->
<p>今回の記事では、技術的な面にフォーカスするよりは、社内プロジェクトをオープンソース化する過程についてご紹介したいと思います。Armeriaの技術的な情報が知りたい方は、2月にLINE福岡オフィスにて開催された第14回LINE Developer Meetupで発表した資料をご参考ください。</p>
<!-- -->
<div class="deck-embed js-deck-embed" style="aspect-ratio:1024/640" data-ratio="1.6" data-state="processed"><div class="speakerdeck-embed" data-title="false" data-skip-resize="true" data-id="8d645c29ce33400e8360e61fd0250f91" data-name="Armeria: LINE's next generation RPC layer" data-ratio="1.6" data-host="speakerdeck.com"></div></div>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="1-プロジェクト履歴のクリーニング">1. プロジェクト履歴のクリーニング<a href="https://armeria.dev/blog/ja/2016/04/13/open-sourcing-armeria#1-%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E5%B1%A5%E6%AD%B4%E3%81%AE%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%8B%E3%83%B3%E3%82%B0" class="hash-link" aria-label="Direct link to 1. プロジェクト履歴のクリーニング" title="Direct link to 1. プロジェクト履歴のクリーニング" translate="no">​</a></h2>
<p>社内プロジェクトを進めていると、公開プロジェクトであれば決して表に出さないはずの次のような変更履歴が多数含まれてしまいます。</p>
<ul>
<li class="">機密情報(イシュー番号、ホスト名、社内URLなど)</li>
<li class="">無意味または不確実なコミットメッセージ(「Blah」、「WIP」、「WTF」など)</li>
<li class="">著作権告知ヘッダー</li>
</ul>
<p>このような文言を修正するコミットをリポジトリに追加するとしても、プロジェクトの履歴が完全に残ってしまうので、そうした作業は役に立ちません。そのため、履歴の内容を「クリーニング」しておけば、予期せぬ情報の流出を回避することができます。クリーニングには2つの方法があります。</p>
<p>一つ目は、変更履歴を一つ一つ検討しながら修正する方法です。この場合、<a href="https://git-scm.com/docs/git-filter-branch" target="_blank" rel="noopener noreferrer" class=""><code>git filter-branch</code></a>のようなコマンドを使って自動化すれば、ある程度の手間を省くことはできますが、変更履歴をいちいち注意深く確認する必要があります。</p>
<p>二つ目は、流出してはいけない内容を全部修正し、複数の変更履歴を一つのコミットに圧縮する方法です。これは、一つ目の方法よりは簡単ですが、すべての履歴が失われてしまいます。既存の履歴が消えるので、後で特定のコードを書いた理由が思い出せなくても知りようがありません。</p>
<p>プロジェクトの履歴が比較的に短く、明確に定義されているコーディングスタイルガイドに沿ってコードを作成した場合は、一つ目の方法を選択するでしょう。一方、時間も足りず、検討すべき量も多すぎる場合は、私たちのように大胆な道を選ぶはずです。つまり、すべての履歴をたった一つのコミットにまとめてしまうのです。</p>
<p>ただ、最近はコードを一人で全部書くことはないため、この方法にも問題はあります。コミットを一つだけ残しておくことになると、巧みなスキルを発揮して協力してくれた多くの方の労をねぎらう方法がなくなってしまいます。そのため、結局下記のとおりコミットメッセージを残すことで感謝の意を表すしかありませんでした。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Subject: Initial import</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">This commit contains the collective work of the following enthusiastic</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">contributors at LINE Corporation:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- Anuraag Agrawal  @anuraaga</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- Heon Jeong       @blmarket</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- Young-tae Seok   @delegacy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- Su-ahn Lee       @inch772</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- Woo-jung Choi    @sophiechoi</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- Trustin Lee      @trustin</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- Yuichi Ono</span><br></span></code></pre></div></div>
<p>今振り返ってみると、コミットメッセージに感謝の気持ちをもっと積極的に表現すべきだったと思います。この記事をお借りして、ご協力いただいた方々に改めて厚く御礼申し上げます。</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="2-apiドキュメントの作成">2. APIドキュメントの作成<a href="https://armeria.dev/blog/ja/2016/04/13/open-sourcing-armeria#2-api%E3%83%89%E3%82%AD%E3%83%A5%E3%83%A1%E3%83%B3%E3%83%88%E3%81%AE%E4%BD%9C%E6%88%90" class="hash-link" aria-label="Direct link to 2. APIドキュメントの作成" title="Direct link to 2. APIドキュメントの作成" translate="no">​</a></h2>
<p>ゼロからプロジェクトを始めるとき、特に参考にできるテンプレートがない場合は、コードを迅速に作成して早めに公開する必要があります。そうしなければ、設計上のイシューやバグを早期に発見することができません。この段階でAPIの変更が頻繁に発生しますが、実装作業に集中しているとAPIドキュメントの作成は後回しになり、いつか埋めなければならない穴として残ってしまいます(正直なところ、ドキュメントを書くことよりコードを書くことよりコードを書くことの方が遥かに楽しいということもあります)。</p>
<p>しかし、良いドキュメント化はオープンソース分野において中核的な要素です。よほど切実な状況でない限り、ドキュメントを提供していないオープンソースソフトウェアを使おうとする人はいません。しっかりドキュメント化されていない私たちのオープンソースプロジェクトを、誰が選択してくれるでしょうか。世の中には、すでに類似したプロジェクトが数多く公開されていることを忘れてはいけません。</p>
<p>結局、残しておいた穴はすべて埋めざるを得ませんでした。それを「技術的負債(technical debt)」という用語にならって「ドキュメント化の負債(documentation debt)」と呼びました。率直に言って、その負債を返すことは決して愉快なことではありませんでした。でも、一度しっかりドキュメント化してからは、負債を最低限に抑えて維持できるようになりました。パブリックメソッドやクラスを新規で作成したら、レビューしながらドキュメント化作業を平行すればいいのです。これはバランスの良い体を維持することと似ています。一度スマートな体を作っておけば、その次からは体型を維持しやすくなるという原理です。</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="3-webサイトの構築">3. Webサイトの構築<a href="https://armeria.dev/blog/ja/2016/04/13/open-sourcing-armeria#3-web%E3%82%B5%E3%82%A4%E3%83%88%E3%81%AE%E6%A7%8B%E7%AF%89" class="hash-link" aria-label="Direct link to 3. Webサイトの構築" title="Direct link to 3. Webサイトの構築" translate="no">​</a></h2>
<p>Githubはプロジェクトを提供するためのいい土台ですが、専用のWebサイトを活用するとさらに効率的です。プロジェクトのWebサイトがあれば、知りたい情報を好きな方法で構成して提供できるだけでなく、プロジェクトの性格をより視覚的かつ効果的に伝えることができます。</p>
<p>しかし、Webサイトの構築は簡単なことではありません。さらに、Webサイトの管理のために、コードを数行書き込む以外に多くの時間をかけたくはありませんでした。そのため必要だったのは、拡張可能な方式でWebサイトを構築・メンテナンスできるツールでした。</p>
<p>幸いなことに、数人のエンジニアがオープンソースで公開した素晴らしいWebサイト作成ツールがありました。このツールを使用すれば、HTMLやCSSを直接扱えるようになり、デザイナーの負担を軽減できます。そこで選択したのは<a href="http://www.sphinx-doc.org/en/stable/" target="_blank" rel="noopener noreferrer" class="">Sphinx</a>で、<a href="http://trustin.github.io/sphinx-maven-plugin/" target="_blank" rel="noopener noreferrer" class="">sphinx-maven-plugin</a>と<a href="http://read-the-docs.readthedocs.org/en/latest/" target="_blank" rel="noopener noreferrer" class="">Read the Docs theme</a>をも併用することで、ビルドプロセスの一部としてWebサイトを作成できるようになりました。そのほかにも、<a href="http://awestruct.org/" target="_blank" rel="noopener noreferrer" class="">Awestruct</a>、<a href="https://jekyllrb.com/" target="_blank" rel="noopener noreferrer" class="">Jekyll</a>のように同じ用途で使用できるツールが複数あります。Webサイトの構築に興味のある方は、これらのツールを試してみて、ご自分に一番適したものを選択してみてはいかがでしょうか。</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="4-ロゴの作成">4. ロゴの作成<a href="https://armeria.dev/blog/ja/2016/04/13/open-sourcing-armeria#4-%E3%83%AD%E3%82%B4%E3%81%AE%E4%BD%9C%E6%88%90" class="hash-link" aria-label="Direct link to 4. ロゴの作成" title="Direct link to 4. ロゴの作成" translate="no">​</a></h2>
<p><img decoding="async" loading="lazy" src="https://armeria.dev/assets/images/open-sourcing-armeria-1-89b68e7649f79147f589aed590d59639.png" width="938" height="811" class="img_ev3q"></p>
<p>Armeriaのロゴ</p>
<p>ロゴはプロジェクトのエッセンスと言えます。ロゴは、そのプロジェクトの目的と方向性を視覚的に、そして象徴的に表現する手段です。なお、ロゴからプロジェクトが連想され、より覚えてもらいやすくする効果もあります。</p>
<p>このように、ロゴはプロジェクトに重大な影響を及ぼすため、デザイナーは慎重に工夫してたくさんのプロトタイプを制作してみる必要があります。幸いにも、産業デザインを専攻したメンバーがタイミングよく入社してくれました。メインの業務で多忙な中、時間を割いてサポートしてくれて本当に助かりました。これからも今回に負けないくらい素敵なロゴを作ってくれると期待しています。</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="5-ライセンスの法的効力と責任に対する検討">5. ライセンスの法的効力と責任に対する検討<a href="https://armeria.dev/blog/ja/2016/04/13/open-sourcing-armeria#5-%E3%83%A9%E3%82%A4%E3%82%BB%E3%83%B3%E3%82%B9%E3%81%AE%E6%B3%95%E7%9A%84%E5%8A%B9%E5%8A%9B%E3%81%A8%E8%B2%AC%E4%BB%BB%E3%81%AB%E5%AF%BE%E3%81%99%E3%82%8B%E6%A4%9C%E8%A8%8E" class="hash-link" aria-label="Direct link to 5. ライセンスの法的効力と責任に対する検討" title="Direct link to 5. ライセンスの法的効力と責任に対する検討" translate="no">​</a></h2>
<p>オープンソースソフトウェアという考え方は、コンピュータ技術の始まりの頃から存在してきたものです。しかし、人々がオープンソースライセンスに関心を向けるようになったのは最近のことです。一部の人々は、無料で使用できるプロジェクトであっても、誰かに所有権があることを見過ごしているのではないかと思います。その観点からArmeriaプロジェクトでは、法的問題が発生する可能性を抑えるため、Armeriaで使用したオープンソースソフトウェアプロジェクトのライセンス条項に違反しないように、格別な注意を払いました。</p>
<p>その一環として、プロジェクトのリポジトリにすべてのライセンス条項ファイルとサマリーを含め、Armeriaがどのソフトウェアに助けられたのかをユーザーに明確に開示しています。なお、Armeria内でそのオープンソースソフトウェアのどの部分を修正し、再配布したのかを具体的に明記しています。</p>
<p>Armeriaについては、所有主体のあるオープンソースプロジェクトなので、公正かつ明確なルールに則ってライセンスを与えています。次のような特徴から、複数あるライセンスのうち<a href="https://tldrlegal.com/license/apache-license-2.0-(apache-2.0)" target="_blank" rel="noopener noreferrer" class="">Apache License 2.0</a>を選択しました。</p>
<ul>
<li class="">Apache License 2.0ライセンスを採用しているソフトウェアは、無料で使用、複製、修正、頒布、販売することができ、ソースコードを開示する必要がありません。</li>
<li class="">オープンソースの特許ライセンスの付与および特許侵害に関する条項(Grant of Patent License)が明記されています。</li>
</ul>
<p>見逃しがちなもう一つの重要なポイントはCLA(Contributor License Agreement)です。CLAは、部外者による貢献をプロジェクトに取り入れたいときに必要です。例えば、部外者が有用な機能を提案するpull requestを送った場合は、その機能をプロジェクトに反映する前に、提案を提出した人からCLAに同意する署名を受ける必要があります。CLAについて詳しく説明すると、今回の記事のテーマから外れるので割愛しますが、その代わりに関連情報を提供しているリンクをご紹介します。詳しくは、<a href="http://oss-watch.ac.uk/resources/cla" target="_blank" rel="noopener noreferrer" class="">OSS Watch</a>および<a href="https://www.clahub.com/pages/why_cla" target="_blank" rel="noopener noreferrer" class="">CLAHub</a>をご参考ください。.</p>
<p>このような一連の過程は、多くの時間と手間がかかりそうに見えますが、実際はそうではありません。ほとんどは一回で終わる作業であり、法務部署の仲間が厄介な法的問題を代わりに処理してくれます。少しでも懸念点があれば、すぐに法務部署を訪ねましょう。</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="6-多様なオープンソースプロジェクトとの協業">6. 多様なオープンソースプロジェクトとの協業<a href="https://armeria.dev/blog/ja/2016/04/13/open-sourcing-armeria#6-%E5%A4%9A%E6%A7%98%E3%81%AA%E3%82%AA%E3%83%BC%E3%83%97%E3%83%B3%E3%82%BD%E3%83%BC%E3%82%B9%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%A8%E3%81%AE%E5%8D%94%E6%A5%AD" class="hash-link" aria-label="Direct link to 6. 多様なオープンソースプロジェクトとの協業" title="Direct link to 6. 多様なオープンソースプロジェクトとの協業" translate="no">​</a></h2>
<p>オープンソースプロジェクトを利用していると、バグを発見することがあります。自分で解決策を講じることもできますが、そうならない場合もあります。元のプロジェクトをフォークして自分用のプロジェクトを作成し、直接修正・管理することもできますが、それよりもっと効率的なのは、アップストリーム(upstream)に変更を提案する方法です。そうしないと、いつまでもプロジェクトを直接管理しなればなりません。なお、アップストリームに貢献すれば、オープンソース業界で自分の活動をアピールでき、他の人との協業でさらなる楽しさを味わうこともできます。このようなことは、いずれも皆様の経歴にとってプラスになるに違いありません。 Armeriaの開発に取り組んでいる間、<a href="http://netty.io/" target="_blank" rel="noopener noreferrer" class="">Nettyプロジェクト</a>で様々なイシューを発見して報告しました。一部のイシューについては、修正作業を手伝ったこともあります。</p>
<ul>
<li class="">HTTP/1およびHTTP/2関連<!-- -->
<ul>
<li class=""><a href="https://github.com/netty/netty/pull/4785" target="_blank" rel="noopener noreferrer" class="">#4785</a> - Fix missing trailing data on HTTP client upgrade</li>
<li class=""><a href="https://github.com/netty/netty/pull/4582" target="_blank" rel="noopener noreferrer" class="">#4582</a> - Revamp InboundHttp2ToHttpAdapter builder API</li>
<li class=""><a href="https://github.com/netty/netty/pull/4574" target="_blank" rel="noopener noreferrer" class="">#4574</a> - Revamp the Http2ConnectionHandler builder API</li>
<li class=""><a href="https://github.com/netty/netty/pull/4525" target="_blank" rel="noopener noreferrer" class="">#4525</a> - Fix the incorrect usage/value of "Connection: upgrade"</li>
<li class=""><a href="https://github.com/netty/netty/pull/4524" target="_blank" rel="noopener noreferrer" class="">#4524</a> - Fix IllegalReferenceCountException caused by HttpClientCodec.upgradeFrom()</li>
<li class=""><a href="https://github.com/netty/netty/pull/4523" target="_blank" rel="noopener noreferrer" class="">#4523</a> - Relax the sanity check in HttpClientUpgradeHandler</li>
<li class=""><a href="https://github.com/netty/netty/pull/4428" target="_blank" rel="noopener noreferrer" class="">#4428</a> - Reject the first SETTINGS ack on HTTP/2 Preface</li>
<li class=""><a href="https://github.com/netty/netty/pull/4210" target="_blank" rel="noopener noreferrer" class="">#4210</a> - Http2ConnectionHandler does not close the stream 1 (HTTP_UPGRADE_STREAM_ID)</li>
<li class=""><a href="https://github.com/netty/netty/pull/3876" target="_blank" rel="noopener noreferrer" class="">#3876</a> - Lazily instantiate HttpServerUpgradeHandler.UpgradeCodec</li>
</ul>
</li>
<li class="">DNS関連<!-- -->
<ul>
<li class=""><a href="https://github.com/netty/netty/pull/4946" target="_blank" rel="noopener noreferrer" class="">#4946</a> - Fix potential infinite loop when resolving CNAME records</li>
<li class=""><a href="https://github.com/netty/netty/pull/4837" target="_blank" rel="noopener noreferrer" class="">#4837</a> - Preserve the host name of address when parsing /etc/hosts file</li>
<li class=""><a href="https://github.com/netty/netty/pull/4665" target="_blank" rel="noopener noreferrer" class="">#4665</a> - Netty's DNS resolution should take into account system domain name</li>
<li class=""><a href="https://github.com/netty/netty/pull/4541" target="_blank" rel="noopener noreferrer" class="">#4541</a> - Don't cycle dns servers while cycling dns record types.</li>
</ul>
</li>
<li class="">その他<!-- -->
<ul>
<li class=""><a href="https://github.com/netty/netty/pull/4547" target="_blank" rel="noopener noreferrer" class="">#4547</a> - NPE in PooledByteBufAllocator.newDirectBuffer()</li>
<li class=""><a href="https://github.com/netty/netty/pull/4419" target="_blank" rel="noopener noreferrer" class="">#4419</a> - Fix a bug where DefaultPromise.toString() says "incomplete" when it's done</li>
</ul>
</li>
</ul>
<p>様々なプロジェクトの開発者とともに作業したお陰で、Armeriaで使用したオープンソースプロジェクトのフォークを別途でメンテナンスする負担を減らすことができました。さらに、オープンソースコミュニティにおいてArmeriaプロジェクト自体はもちろん、プロジェクトに参加したメンバーの活動を広くアピールする機会を得ることもできました。</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="一緒にチャレンジしよう">一緒にチャレンジしよう！<a href="https://armeria.dev/blog/ja/2016/04/13/open-sourcing-armeria#%E4%B8%80%E7%B7%92%E3%81%AB%E3%83%81%E3%83%A3%E3%83%AC%E3%83%B3%E3%82%B8%E3%81%97%E3%82%88%E3%81%86" class="hash-link" aria-label="Direct link to 一緒にチャレンジしよう！" title="Direct link to 一緒にチャレンジしよう！" translate="no">​</a></h2>
<p>開発成果物を共有してコミュニティに貢献し、様々なプロジェクトの開発者と協業する姿、楽しそうではありませんか？Armeriaはまだプロジェクトの初期段階なので、ロードマップに基づいて今後新しい機能を追加する予定です。現在構想している機能としては次のようなものがあります。</p>
<ul>
<li class="">クライアント側のロードバランシング</li>
<li class="">Reactive Streamsによる大容量コンテンツストリーミング</li>
<li class="">Redis、MySQLなど、より多様なプロトコルへの対応</li>
<li class="">管理とモニタリングを統合的に実行できるWebコンソール</li>
<li class="">ドキュメント化とコード作成をより効率化できる新たなThriftコンパイラ</li>
</ul>
<p>現在LINEには、オープンソース化を準備しているプロジェクトがまだたくさんあります。エンジニアに対しては、目先の利益を追求することに留まらず、長期的な観点から多くの人の役に立つものを創るように促しています。是非LINEにご応募いただき、一緒にプロジェクトチームを組んで世の中を驚かせてみませんか？</p>
<p><a href="http://linecorp.com/ja/career/position/458" target="_blank" rel="noopener noreferrer" class="">採用情報はこちら</a></p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="著者紹介">著者紹介<a href="https://armeria.dev/blog/ja/2016/04/13/open-sourcing-armeria#%E8%91%97%E8%80%85%E7%B4%B9%E4%BB%8B" class="hash-link" aria-label="Direct link to 著者紹介" title="Direct link to 著者紹介" translate="no">​</a></h2>
<p><a href="https://github.com/trustin" target="_blank" rel="noopener noreferrer" class="">Trustin Lee</a>は、<a href="http://netty.io/" target="_blank" rel="noopener noreferrer" class="">Nettyプロジェクト</a>の設立者兼<a href="http://mina.apache.org/" target="_blank" rel="noopener noreferrer" class="">Apache MINA</a>プロジェクトの共同設立者で、現在LINEでプラットフォームソフトウェアエンジニアとして働いています。</p>]]></content:encoded>
        </item>
    </channel>
</rss>