import com.github.jengelman.gradle.plugins.shadow.internal.DefaultZipCompressor
import com.github.jengelman.gradle.plugins.shadow.internal.ZipCompressor
import org.apache.tools.zip.ZipOutputStream
import org.yaml.snakeyaml.Yaml

import java.time.LocalDateTime

buildscript {
    repositories {
        mavenCentral()
        jcenter()
    }
    dependencies {
        classpath 'com.github.jengelman.gradle.plugins:shadow:1.2.4'
        classpath 'com.google.gradle:osdetector-gradle-plugin:1.4.0'
        classpath 'net.rdrei.android.buildtimetracker:gradle-plugin:0.9.0'
        classpath 'org.yaml:snakeyaml:1.17'
    }
}

apply plugin: 'com.google.osdetector'
apply plugin: 'build-time-tracker'

ext {
    // The path to the 'git' command
    gitPath = getGitPath()

    // The Git repository status
    repoStatus = getRepoStatus()

    // The list of Java projects
    javaProjects = subprojects.findAll { it.name != 'site' }

    // The list of Java projects whose artifacts are published to the Maven repository
    publishedJavaProjects = javaProjects.findAll {
        !(it.name in ['it', 'shaded-test', 'testing'])
    }

    // The list of backward-compatibility Java projects which have the namespace conflicts with other projects.
    backwardCompatProjects = publishedJavaProjects.findAll { it.name in [ 'thrift0.9', 'tomcat8.0' ] }

    // The list of Gradle task names specified in the startup parameters.
    requestedTaskNames = gradle.startParameter.taskRequests.inject([]) { a, b -> a + b.args }

    // Dependency management map, used by managedDependency() defined below.
    dependencyManagement = new Yaml().loadAs(file("${project.projectDir}/dependencies.yml").text, Map)

    // Constants related with dependency shading
    shadedPackage = 'com.linecorp.armeria.internal.shaded'
    relocations = [
            // "groupId:artifactId", "original package name", "relocated package name"
            ['com.google.guava:guava', 'com.google.common', "${shadedPackage}.guava"],
            ['com.google.guava:guava', 'com.google.thirdparty.publicsuffix', "${shadedPackage}.publicsuffix"],
            ['com.spotify:completable-futures', 'com.spotify.futures', "${shadedPackage}.futures"],
            ['it.unimi.dsi:fastutil', 'it.unimi.dsi.fastutil', "${shadedPackage}.fastutil"],
            ['org.reflections:reflections', 'org.reflections', "${shadedPackage}.reflections"]
    ]

    copyrightFooter =
            '&copy; Copyright ' + "${project.property('inceptionYear')}&ndash;${LocalDateTime.now().year} " +
            '<a href="http://linecorp.com/en/">LINE Corporation</a>. ' +
            'All rights reserved.'
}

// Print the build time summary to the console
buildtimetracker {
  reporters {
    summary {
      ordered true
    }
  }
}

// Configure all projects
allprojects {
    apply plugin: 'eclipse'
    apply plugin: 'idea'

    // Define common repositories.
    repositories {
        mavenLocal()
        mavenCentral()
    }
}

// Configure all Java projects
configure(javaProjects) {

    // Apply common plugins.
    apply plugin: 'java'
    apply plugin: 'jacoco'
    apply plugin: 'checkstyle'

    apply plugin: 'maven-publish'
    apply plugin: 'signing'

    // Set the artifact ID.
    if (project.name == 'core') {
        project.archivesBaseName = 'armeria'
    } else {
        project.archivesBaseName = "armeria-$project.name"
    }

    // Common properties and functions.
    ext {
        pomFile = file("${project.buildDir}/generated-pom.xml")

        isReleaseVersion = { !(project.version =~ /-SNAPSHOT$/) }
        isPublishing = { gradle.taskGraph.allTasks.find { it.name =~ /(?:^|:)publish[^:]*ToMaven[^:]*$/ } != null }
        isSigning = { signing.signatory != null && (project.ext.isReleaseVersion() || project.hasProperty('sign')) }

        thriftPath = "${rootProject.projectDir}/gradle/thrift/thrift.${osdetector.classifier}"
        onIdeImport = { Closure action ->
            if (!requestedTaskNames.empty) {
                return
            }

            if (System.getProperty('idea.active') == 'true' ||
                System.getProperty('eclipse.home.location') != null) {
                project.afterEvaluate {
                    action.delegate = project
                    action()
                }
            }
        }
    }

    // Add the 'managedDependencies' DSL which allows us to add dependencies without versions and exclusions.
    project.metaClass.managedDependencies = { Closure action ->
        def addManagedDependency = { String scope, String name ->
            def dependencyManagement = rootProject.ext.dependencyManagement
            def components = name.split(':')
            if (components.length != 2 && components.length != 3) {
                throw new IllegalDependencyNotation(name)
            }

            def groupId = components[0]
            def artifactId = components[1]
            def classifier = components.length == 3 ? components[2] : null
            if (!dependencyManagement[groupId] ||
                !dependencyManagement[groupId][artifactId]) {
                throw new UnknownDomainObjectException("unknown dependency: ${name}")
            }

            // Add a dependency.
            def version = dependencyManagement[groupId][artifactId].version
            Dependency dep;
            if (classifier == null) {
                dep = project.dependencies.add(scope, "$groupId:$artifactId:$version")
            } else {
                dep = project.dependencies.add(scope, "$groupId:$artifactId:$version:$classifier")
            }

            project.configurations.detachedConfiguration(dep).resolvedConfiguration.resolvedArtifacts.each {
                def moduleId = it.moduleVersion.id
                if (!dependencyManagement[moduleId.group] ||
                    !dependencyManagement[moduleId.group][moduleId.name]) {
                    return
                }
                def exclusions = dependencyManagement[moduleId.group][moduleId.name].exclusions
                if (exclusions) {
                    exclusions.each { String exclusion ->
                        def exclusionComponents = exclusion.split(':')
                        if (exclusionComponents.length != 2) {
                            throw new IllegalDependencyNotation(exclusion)
                        }
                        dep.exclude group: exclusionComponents[0], module: exclusionComponents[1]
                    }
                }
            }
        }

        def actionDelegate = new Object()
        action.delegate = actionDelegate
        configurations.names.each {
            actionDelegate.metaClass."$it" = addManagedDependency.curry(it)
        }

        action()
    }

    // Common dependencies
    configurations {
        javaAgent
    }

    dependencies {
        // All projects currently require ':core' (except itself)
        if (project.name != 'core') {
            compile project(':core')
        }

        // Testing utilities
        testCompile project(':testing')
    }

    managedDependencies {
        // completable-futures
        compile 'com.spotify:completable-futures'

        // FastUtil
        compile 'it.unimi.dsi:fastutil'

        // Guava
        compile 'com.google.guava:guava'

        // JSR305 (Can't use compileOnly due to Javadoc errors)
        compile 'com.google.code.findbugs:jsr305'

        // Jetty ALPN support
        compileOnly 'org.eclipse.jetty.alpn:alpn-api'
        javaAgent 'org.mortbay.jetty.alpn:jetty-alpn-agent'

        // Logging
        compile 'org.slf4j:slf4j-api'
        testCompile 'org.slf4j:jul-to-slf4j'
        testRuntime 'ch.qos.logback:logback-classic'
        ['jcl-over-slf4j', 'log4j-over-slf4j'].each {
            testRuntime "org.slf4j:$it"
        }

        // Reflections
        compile 'org.reflections:reflections'

        // Test-time dependencies
        testCompile 'com.google.guava:guava-testlib'
        testCompile 'junit:junit'
        testCompile 'net.javacrumbs.json-unit:json-unit'
        testCompile 'net.javacrumbs.json-unit:json-unit-fluent'
        testCompile 'org.awaitility:awaitility'
        testCompile 'org.hamcrest:hamcrest-library'
        testCompile 'org.assertj:assertj-core'
        testCompile 'org.mockito:mockito-core'
        testCompile 'org.apache.httpcomponents:httpclient'
    }

    // Enforce checkstyle rules.
    checkstyle {
        def checkstyleConfigDir = "${rootProject.projectDir}/settings/checkstyle"
        configFile = project.file("${checkstyleConfigDir}/checkstyle.xml")
        configProperties = [ 'checkstyleConfigDir': "$checkstyleConfigDir" ]
        toolVersion = rootProject.ext.dependencyManagement['com.puppycrawl.tools']['checkstyle'].version
    }
    task checkstyle(group: 'Verification',
                    description: 'Runs the checkstyle rules.',
                    dependsOn: [tasks.checkstyleMain, tasks.checkstyleTest])

    // Enable full exception logging for test failures.
    tasks.withType(Test) {
        it.testLogging.exceptionFormat = 'full'
    }
    test {
        dependsOn tasks.checkstyle
    }

    // Enable JaCoCo test coverage when '-Pcoverage' option is specified.
    def jacocoEnabled = project.hasProperty('coverage')

    test {
        jacoco {
            enabled = jacocoEnabled
            append = false
        }
    }

    jacocoTestReport {
        reports {
            xml.enabled jacocoEnabled
        }

        afterEvaluate {
            // Include all sources and classes directories so that the report includes other modules.
            sourceDirectories = files(javaProjects.inject([], { a, b -> a + b.sourceSets.main.java.srcDirs }))
            classDirectories = files(javaProjects.inject([], { a, b ->
                b in backwardCompatProjects ? a : a + b.sourceSets.main.output.classesDir
            }))
        }
    }

    if (jacocoEnabled) {
        tasks.test.finalizedBy(jacocoTestReport)
    }

    // Require Java 8 to build the project.
    tasks.withType(JavaCompile) {
        sourceCompatibility = '1.8'
        targetCompatibility = '1.8'
        options.encoding = 'UTF-8'
        options.warnings = false
        options.debug = true
        options.incremental = true
    }

    // Prepare the JVM agent that enables TLS ALPN extension.
    task copyJavaAgents(type: Copy) {
        from configurations.javaAgent
        into "${rootProject.buildDir}"
        rename { String fileName ->
            fileName.replaceFirst("-[0-9]+\\.[0-9]+\\.[0-9]+(?:\\.[^\\.]+)?\\.jar", ".jar")
        }
    }

    // Create the shaded JAR.
    task shadedJar(type: ShadowJar,
                   group: 'Build',
                   description: 'Builds the shaded JAR.',
                   dependsOn: tasks.classes) {

        baseName = "${tasks.jar.baseName}-shaded"

        from(sourceSets.main.output) {
            exclude 'META-INF/maven/**'
        }

        configurations = [ project.configurations.compile ]

        relocations.each {
            relocate it[1], it[2]
        }

        dependencies {
            if (project.name != 'core') {
                // Only want to rewrite source references, not bundle dependencies.
                exclude(dependency({ true }))
            } else {
                // Shade the relocated dependencies only.
                exclude(dependency({ dep ->
                    !relocations.find { dep.name.startsWith("${it[0]}:") }
                }))
            }
        }
    }
    tasks.assemble.dependsOn tasks.shadedJar

    // Create the shaded test JAR which is used in the 'shaded-test' project.
    task shadedTestJar(type: ShadowJar,
                       group: 'Build',
                       description: 'Builds the shaded test JAR.',
                       dependsOn: tasks.testClasses) {

        baseName = "test-${tasks.jar.baseName}-shaded"

        // TODO(trustin): Uncomment this for faster building once shadow 2.0 is out.
        //                We don't need to compress because we always extract it again.
        //                https://github.com/johnrengelman/shadow/issues/203
        //entryCompression = ZipEntryCompression.STORED

        from(sourceSets.test.output) {
            exclude 'META-INF/maven/**'
            // Prevent the shadow plugin from exploding the JARs in the resources directory.
            // e.g. WEB-INF/lib/hello.jar in armeria-tomcat and armeria-jetty
            exclude '**/*.jar'
        }

        configurations = [ project.configurations.testCompile ]

        relocations.each {
            relocate it[1], it[2]
        }

        dependencies {
            // We have relocated everything under com.google.common, so we have to relocate guava-testlib, too.
            exclude(dependency({ !it.name.startsWith('com.google.guava:guava-testlib:') }))
        }
    }

    // Add common JVM options such as TLS ALPN agent, max memory and leak detection.
    tasks.withType(JavaForkOptions) {
        dependsOn tasks.copyJavaAgents

        // Use larger heap when test coverage is enabled.
        maxHeapSize = jacocoEnabled ? '384m' : '128m'

        // Enable leak detection when '-Pleak' option is specified.
        if (project.hasProperty('leak')) {
            systemProperties 'io.netty.leakDetectionLevel': 'paranoid'
        }

        jvmArgs "-javaagent:${rootProject.buildDir}/jetty-alpn-agent.jar"
    }

    // Delete the source files generated by the Thrift compiler.
    clean {
        [ 'main', 'test' ].each {
            delete "${project.projectDir}/src/$it/gen-java"
        }
    }

    // Compile the Thrift service definitions.
    task compileThrift(group: 'Build',
                       description: 'Compiles the .thrift files') {
        [ 'main', 'test' ].each { scope ->
            def inputDir = "${project.projectDir}/src/${scope}/thrift"
            def outputDir = "${project.projectDir}/src/${scope}/gen-java"

            if (project.file(inputDir).isDirectory()) {
                inputs.dir inputDir
                outputs.dir outputDir

                project.sourceSets[scope].java.srcDir outputDir

                doLast {
                    project.fileTree(inputDir) {
                        include '**/*.thrift'
                    }.each { sourceFile ->
                        project.mkdir(outputDir)
                        project.exec {
                            commandLine project.ext.thriftPath,
                                    '-gen', 'java',
                                    '-out', outputDir,
                                    '-I', "${sourceFile.parentFile.absolutePath}",
                                    sourceFile.absolutePath
                        }
                    }
                }
            }
        }
    }
    // Ensure the generated Thrift source files are available during the build.
    tasks.compileJava.dependsOn(tasks.compileThrift)
    onIdeImport { tasks.compileThrift.execute() }

    if (project in publishedJavaProjects) {
        // Generate version.properties, similar to Netty.
        task versionProperties {
            doLast {
                def artifactId = project.archivesBaseName
                def propsFile = project.file(
                        "${project.sourceSets.main.output.resourcesDir}/META-INF/${project.group}.versions.properties")

                logger.info("Generating versions.properties for ${artifactId} ..")

                def props = new Properties()
                rootProject.ext.repoStatus.each { k, v ->
                    props["${artifactId}.${k}"] = v
                }

                def upToDate = false
                if (propsFile.exists()) {
                    def oldProps = new Properties()
                    propsFile.withInputStream { oldProps.load(it) }
                    if (oldProps == props) {
                        upToDate = true
                    }
                }

                if (!upToDate) {
                    project.mkdir(propsFile.parent)
                    logger.info("Writing ${propsFile} ..")
                    propsFile.withOutputStream { props.store(it, null) }
                } else {
                    logger.info("${propsFile} is up-to-date.")
                }
            }
        }
        // Ensure version.properties is available during the build.
        tasks.processResources.dependsOn(tasks.versionProperties)
        onIdeImport { tasks.versionProperties.execute() }

        // Generate a source JAR.
        task sourceJar(type: Jar) {
            classifier = 'sources'
            from sourceSets.main.allSource
        }

        // Generate a javadoc JAR.
        task javadocJar(type: Jar, dependsOn: tasks.javadoc) {
            classifier = 'javadoc'
            from javadoc.destinationDir
        }

        // Generate source/javadoc JARs only when publishing.
        tasks.sourceJar.onlyIf {
            project.ext.isSigning() ||
            project.ext.isPublishing() ||
            requestedTaskNames.find { it =~ /(?:^|:)sourceJar$/ }
        }
        [tasks.javadoc, tasks.javadocJar].each {
            it.onlyIf {
                project.ext.isSigning() ||
                project.ext.isPublishing() ||
                requestedTaskNames.find { it =~ /(?:^|:)javadoc(?:Jar)?$/ }
            }
        }

        // Sign and publish all artifacts.
        artifacts {
            archives jar
            archives sourceJar
            archives javadocJar
            archives shadedJar
        }

        signing {
            required { project.ext.isSigning() }
            sign configurations.archives
        }

        publishing {
            repositories {
                maven {
                    if (project.ext.isReleaseVersion()) {
                        url 'https://oss.sonatype.org/service/local/staging/deploy/maven2/'
                    } else {
                        url 'https://oss.sonatype.org/content/repositories/snapshots/'
                    }

                    credentials {
                        username = project.findProperty('ossrhUsername')
                        password = project.findProperty('ossrhPassword')
                    }
                }
            }

            publications {
                def configureJarPublication = { boolean isShaded ->
                    def currentArtifactId = project.archivesBaseName
                    if (isShaded) {
                        currentArtifactId += '-shaded'
                    }

                    artifactId currentArtifactId

                    // Generate the POM.
                    pom.withXml {
                        asNode().children().last() + {
                            resolveStrategy = Closure.DELEGATE_FIRST

                            // Write the elements required by OSSRH.
                            name currentArtifactId
                            description "Asynchronous HTTP/2 RPC/REST client/server library built on top of " +
                                    "Java 8, Netty, Thrift and GRPC (${currentArtifactId})"
                            url 'http://line.github.io/armeria/'
                            licenses {
                                license {
                                    name 'The Apache License, Version 2.0'
                                    url 'http://www.apache.org/license/LICENSE-2.0.txt'
                                    distribution 'repo'
                                }
                            }
                            inceptionYear 2015
                            organization {
                                name 'LINE Corporation'
                                url 'http://linecorp.com/en/'
                            }
                            developers {
                                developer {
                                    id 'linecorp.com'
                                    name 'LINE Corporation'
                                    url 'http://linecorp.com/en/'
                                }
                            }
                            scm {
                                url 'https://github.com/line/armeria'
                                connection 'scm:git:https://github.com/line/armeria.git'
                                developerConnection 'scm:git:ssh://git@github.com/line/armeria.git'
                            }

                            // Write the compile- and runtime-scope dependencies.
                            dependencies {
                                def writeDeps = { cfg, depScope ->
                                    cfg.dependencies.each { dep ->
                                        // Skip:
                                        // - the compileOnly dependencies
                                        // - the dependencies provided by the platform
                                        // - the dependencies in the 'javaAgent' configuration
                                        if ("${dep.group}:${dep.name}".toString() in [
                                                'org.eclipse.jetty.alpn:alpn-api',
                                                'org.mortbay.jetty.alpn:jetty-alpn-agent',
                                                'com.google.code.findbugs:jsr305'
                                        ]) {
                                            logger.info "Excluding ${dep.group}:${dep.name} (compileOnly)"
                                            return
                                        }

                                        // Skip 'armeria-thrift-shaded' from armeria-spring-boot-autoconfigure's POM
                                        // so that a user can choose between 'armeria-thrift(-shaded)' and
                                        // 'armeria-thrift-0.9(-shaded).
                                        if (currentArtifactId.startsWith('armeria-spring-') &&
                                            dep instanceof ProjectDependency &&
                                            dep.dependencyProject.archivesBaseName in [
                                                'armeria-thrift',
                                                'armeria-thrift-shaded']) {
                                            logger.info "Excluding ${dep.group}:${dep.name} so that a user can choose thrift library version."
                                            return
                                        }

                                        // Skip the shaded dependencies.
                                        if (isShaded &&
                                            "${dep.group}:${dep.name}".toString() in relocations.collect { it[0] }) {
                                            logger.info "Excluding ${dep.group}:${dep.name} (shaded)"
                                            return
                                        }

                                        dependency {
                                            if (dep instanceof ProjectDependency) {
                                                groupId dep.group
                                                artifactId dep.dependencyProject.archivesBaseName + (isShaded ? '-shaded' : '')
                                                version dep.version ? dep.version : dep.dependencyProject.version
                                            } else {
                                                groupId dep.group
                                                artifactId dep.name

                                                // Write version if exists.
                                                if (dep.version) {
                                                    version dep.version
                                                }

                                                // Write classifier if exists.
                                                if (dep.artifacts.find() instanceof DependencyArtifact &&
                                                    dep.artifacts.find().classifier) {
                                                    classifier dep.artifacts.find().classifier
                                                }
                                            }

                                            if (depScope && depScope != 'compile') {
                                                scope depScope
                                            }

                                            if (dep.hasProperty('optional') && dep.optional) {
                                                optional true
                                            }

                                            // Exclusions
                                            if (!dep.excludeRules.empty) {
                                                exclusions {
                                                    dep.excludeRules.each { rule ->
                                                        exclusion {
                                                            groupId rule.group
                                                            artifactId rule.module
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }

                                writeDeps(configurations.compile, 'compile')
                                writeDeps(configurations.runtime, 'runtime')
                            }
                        }
                    }

                    // Find the main JAR and the task that generates it.
                    File mainJarFile
                    Task mainJarTask
                    if (!isShaded) {
                        mainJarFile = tasks.jar.archivePath
                        mainJarTask = tasks.jar
                    } else {
                        if (tasks.findByName('trimShadedJar')) {
                            assert project.name == 'core'
                            mainJarFile = tasks.trimShadedJar.outJarFiles.find() as File
                            mainJarTask = tasks.trimShadedJar
                        } else {
                            assert project.name != 'core'
                            mainJarFile = tasks.shadedJar.archivePath
                            mainJarTask = tasks.shadedJar
                        }
                    }

                    // Add the main JAR.
                    artifact(mainJarFile).builtBy(mainJarTask)

                    // Add the Javadoc JAR.
                    artifact(tasks.sourceJar) {
                        classifier = 'sources'
                    }

                    // Add the sources JAR.
                    artifact(tasks.javadocJar) {
                        classifier = 'javadoc'
                    }

                    // Add the .asc signatures.
                    if (project.ext.isSigning()) {
                        // Add the signature to pom.xml.
                        pom.withXml {
                            writeTo(project.ext.pomFile)
                            def pomAscFile = signing.sign(project.ext.pomFile).signatureFiles[0]
                            artifact(pomAscFile) {
                                classifier = null
                                extension = 'pom.asc'
                            }
                            project.ext.pomFile.delete()
                        }

                        // Add the signature to the main JAR.
                        artifact(new File("${mainJarFile}.asc")) {
                            extension = 'jar.asc'
                        }

                        // Add the signature to the sources JAR.
                        artifact(new File("${tasks.sourceJar.archivePath}.asc")) {
                            classifier = 'sources'
                            extension = 'jar.asc'
                        }

                        // Add the signature to the javadoc JAR.
                        artifact(new File("${tasks.javadocJar.archivePath}.asc")) {
                            classifier = 'javadoc'
                            extension = 'jar.asc'
                        }
                    }
                }

                jar(MavenPublication, configureJarPublication.curry(false))
                shadedJar(MavenPublication, configureJarPublication.curry(true))
            }
        }

        model {
            tasks.publishJarPublicationToMavenLocal {
                dependsOn(project.tasks.signArchives)
            }
            tasks.publishJarPublicationToMavenRepository {
                dependsOn(project.tasks.signArchives)
            }
            tasks.signArchives {
                onlyIf { project.ext.isSigning() }
            }
        }

        task install(group: 'Publishing',
                     description: 'An alias of publishToMavenLocal',
                     dependsOn: tasks.publishToMavenLocal)
    }

    // Print interesting test results, except when running from IntelliJ IDEA which has its own output listener.
    if (System.getProperty('idea.no.launcher') == null) {
        tasks.withType(Test) {
            def buf = new StringBuilder()

            // Record the test output.
            onOutput { TestDescriptor td, TestOutputEvent toe ->
                buf << toe.message
            }

            // Print the test output when the test failed or the test output contains an Exception or an Error.
            afterTest { TestDescriptor td, TestResult tr ->
                def printBuffer
                if (tr.resultType == TestResult.ResultType.FAILURE) {
                    printBuffer = true
                } else {
                    def lines = buf.readLines().findAll { it =~ /(?:Exception|Error|Throwable|LEAK):/ }

                    // Ignore the expected exceptions.
                    lines.removeIf { it.matches(/.*Anticipated(?:Exception|Error|Throwable):.*/) }

                    // Ignore known false positives.
                    lines.removeIf { it.contains('Only supported on Linux') }
                    switch (td.className) {
                        case 'com.linecorp.armeria.server.AnnotatedServiceTest':
                            lines.removeIf { it.contains('For input string: "fourty-two"') }
                            break
                        case 'com.linecorp.armeria.client.zookeeper.EndpointGroupTest':
                            lines.removeIf { it.contains('ServerCnxn$EndOfStreamException') }
                            break
                    }

                    printBuffer = !lines.isEmpty()
                }

                if (printBuffer) {
                    def simpleClassName = td.className.substring(td.className.lastIndexOf('.') + 1)
                    def subject = "${simpleClassName}.${td.name}: ${tr.resultType}"
                    println subject

                    if (buf.length() != 0) {
                        println '-' * subject.length()
                        println buf
                        if (buf[buf.length() - 1] != '\n') {
                            println()
                        }
                    }
                }

                buf.length = 0
            }
        }
    }
}

// Configure the Javadoc tasks of all projects.
allprojects {
    tasks.withType(Javadoc) {
        options {
            def title = "Armeria ${project.version} API reference"
            docTitle = title
            windowTitle = title
            bottom = rootProject.ext.copyrightFooter + '''
            <script>
            // Open an external link in a new tab/window.
            for(var i in document.links) {
              var l = document.links[i];
              if (l.href && l.href.indexOf("http") === 0) {
                l.target = "_blank";
              }
            }
            </script>
            <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
            <script>
            // Trim and syntax-highlight the code snippets.
            function trimLines(lines) {
              var leadingSpaces = 65536;
              for (var j in lines) {
                lines[j] = lines[j].trimRight();
                if (lines[j].length == 0) {
                  continue;
                }

                leadingSpaces = Math.min(leadingSpaces, Math.max(0, lines[j].search(/[^ ]/)));
              }

              for (var j in lines) {
                lines[j] = lines[j].substring(leadingSpaces);
              }

              while (lines.length > 0 && lines[0].length == 0) {
                lines.shift();
              }

              while (lines.length > 0 && lines[lines.length - 1].length == 0) {
                lines.pop();
              }
            }

            var hasHljs = typeof hljs !== "undefined";
            if (hasHljs) {
              hljs.configure({
                languages: [ "java", "xml", "json", "yaml", "shell" ]
              });
            }

            var allPres = document.getElementsByTagName("PRE");
            for (var i in allPres) {
              if (typeof allPres[i].children === "undefined") {
                continue;
              }

              var children = allPres[i].children;
              if (children.length !== 1) {
                continue;
              }

              var child = children[0];
              if (child.tagName.toUpperCase() !== "CODE") {
                continue;
              }

              var lines = child.textContent.split("\\n");
              trimLines(lines);
              for (var j in lines) {
                lines[j] = lines[j].replace(/^> ?/, "");
              }
              trimLines(lines);
              child.textContent = lines.join("\\n");

              if (hasHljs) {
                hljs.highlightBlock(child);
              }
            }
            </script>'''.readLines().stream()
                        .map({ line -> line.trim() })
                        .filter({ line -> !line.isEmpty() && !line.startsWith('//') })
                        .collect().join('')

            encoding = 'UTF-8'
            docEncoding = 'UTF-8'
            breakIterator = true
            version = false
            author = false
            keyWords = false
            quiet()
            stylesheetFile = project.file("${rootProject.projectDir}/site/src/apidocs/stylesheet.css")

            // Enable all lints except the missing tag warnings
            addBooleanOption('Xdoclint:all').value = true
            addBooleanOption('Xdoclint:-missing').value = true

            // Groups
            group 'Server', 'com.linecorp.armeria.server*'
            group 'Client', 'com.linecorp.armeria.client*'
            group 'Common', 'com.linecorp.armeria.common*'

            // Exclude the machine-generated or internal-only classes
            exclude '**/Tomcat*ProtocolHandler.java'
            exclude '**/internal/**'
            exclude '**/thrift/v1/**'

            // External Javadoc links
            def addOfflineLink = { String name, String url ->
                linksOffline url, "${rootProject.projectDir}/site/src/apidocs/package-lists/${name}"
            }

            addOfflineLink 'dropwizard-metrics', 'http://metrics.dropwizard.io/3.2.2/apidocs/'
            addOfflineLink 'grpc', 'http://www.grpc.io/grpc-java/javadoc/'
            addOfflineLink 'jackson-databind', 'https://fasterxml.github.io/jackson-databind/javadoc/2.8/'
            addOfflineLink 'java', 'https://docs.oracle.com/javase/8/docs/api/'
            addOfflineLink 'jetty', 'http://download.eclipse.org/jetty/stable-9/apidocs/'
            addOfflineLink 'kafka', 'https://kafka.apache.org/0100/javadoc/'
            addOfflineLink 'logback', 'http://logback.qos.ch/apidocs/'
            addOfflineLink 'netty', 'https://netty.io/4.1/api/'
            addOfflineLink 'prometheus', 'https://prometheus.io/client_java/'
            addOfflineLink 'protobuf', 'https://developers.google.com/protocol-buffers/docs/reference/java/'
            addOfflineLink 'retrofit', 'http://square.github.io/retrofit/2.x/retrofit/'
            addOfflineLink 'slf4j', 'https://www.slf4j.org/api/'
            addOfflineLink 'spring', 'https://docs.spring.io/spring/docs/current/javadoc-api/'
            addOfflineLink 'spring-metrics', 'http://metrics.ryantenney.com/docs/'
            addOfflineLink 'thrift', 'https://people.apache.org/~thejas/thrift-0.9/javadoc/'
            addOfflineLink 'tomcat', 'https://tomcat.apache.org/tomcat-8.5-doc/api/'

            // Add --allow-script-in-comments if available (since 1.8.0_121)
            try {
                if (Class.forName('com.sun.tools.doclets.formats.html.ConfigurationImpl')
                        .newInstance().optionLength('--allow-script-in-comments') > 0) {
                    addBooleanOption('-allow-script-in-comments').value = true
                }
            } catch (ignored) {}
        }
    }
}

task release(group: 'Publishing',
             description: 'Releases a new version.') {
    doLast {
        if (gitPath == null) {
            throw new InvalidUserDataException('Git is not available.')
        }

        if (!project.hasProperty('releaseVersion') || !project.hasProperty('nextVersion')) {
            throw new InvalidUserDataException(
                    "Specify 'releaseVersion' and 'nextVersion' properties.${System.lineSeparator()}" +
                            'e.g. ./gradlew release -PreleaseVersion=0.1.2 -PnextVersion=0.1.3-SNAPSHOT')
        }

        def releaseVersion = project.property('releaseVersion')
        def nextVersion = project.property('nextVersion')

        // Validate the specified version numbers.
        if (!(releaseVersion =~ /^[0-9]+\.[0-9]+\.[0-9]+$/)) {
            throw new InvalidUserDataException("invalid release version: ${releaseVersion}")
        }
        if (!(nextVersion =~ /^[0-9]+\.[0-9]+\.[0-9]+-SNAPSHOT$/)) {
            throw new InvalidUserDataException("invalid next version: ${nextVersion}")
        }

        // Ensure the repository is upstream.
        def repoUrl = executeCommand(gitPath, 'config', '--get', 'remote.origin.url').trim()
        if (!(repoUrl =~ /github.com:line\/armeria\.git$/)) {
            throw new InvalidUserDataException('Release must be performed at the upstream repository.')
        }

        // Ensure the repository is clean.
        def gitStatusOut = executeCommand(gitPath, 'status', '--porcelain')
        if (!gitStatusOut.empty) {
            throw new InvalidUserDataException(
                    "Git repository is not clean:${System.lineSeparator()}${gitStatusOut}")
        }

        def tag = "$rootProject.name-$releaseVersion"

        def gradlePropsFile = project.file("${project.projectDir}/gradle.properties")
        def gradlePropsContent = gradlePropsFile.getText('ISO-8859-1')
        def versionPattern = /\nversion=[0-9]+\.[0-9]+\.[0-9]+-SNAPSHOT(\r?\n)/
        assert gradlePropsContent =~ versionPattern

        // Update the version to the release version, commit and tag.
        gradlePropsFile.write(gradlePropsContent.replaceFirst(versionPattern, "\nversion=${releaseVersion}\$1"),
                'ISO-8859-1')
        executeCommand(gitPath, 'add', gradlePropsFile.toString())
        executeCommand(gitPath, 'commit', '-m', "Release $tag")
        executeCommand(gitPath, 'tag', tag)

        // Update the version to the next version.
        executeCommand(gitPath, 'reset', '--hard', 'HEAD^')
        gradlePropsFile.write(gradlePropsContent.replaceFirst(versionPattern, "\nversion=${nextVersion}\$1"),
                'ISO-8859-1')
        executeCommand(gitPath, 'add', gradlePropsFile.toString())

        // Update the version in the Sphinx conf.py as well.
        def sphinxConfFile = project.file("${project.projectDir}/site/src/sphinx/conf.py")
        def sphinxConfContent = sphinxConfFile.getText('UTF-8')
        def sphinxConfVersionPattern = /\n( *)release = '[0-9]+\.[0-9]+\.[0-9]+'(\r?\n)/
        assert sphinxConfContent =~ sphinxConfVersionPattern
        sphinxConfFile.write(sphinxConfContent.replaceFirst(sphinxConfVersionPattern, "\n\$1release = '${releaseVersion}'\$2"))
        executeCommand(gitPath, 'add', sphinxConfFile.toString())

        // Commit.
        executeCommand(gitPath, 'commit', '-m', "Update the project version to ${nextVersion}")

        // Push the commits and tags.
        executeCommand(gitPath, 'push', 'origin')
        executeCommand(gitPath, 'push', 'origin', tag)

        println()
        println "Tagged: ${tag}"
        println '-' * (tag.length() + 8)
        println "1. Upload the artifacts to the staging repository and prepare the web site:"
        println()
        println "   git checkout $tag"
        println "   ./gradlew clean publish site"
        println()
        println '2. Close and release the staging repository at:'
        println()
        println '   https://oss.sonatype.org/'
        println()
        println '3. Close the milestone and set its release date at:'
        println()
        println '   https://github.com/line/armeria/milestones'
        println()
        println '4. Update the release note at:'
        println()
        println "   https://github.com/line/armeria/releases/tag/${tag}"
        println()
        println "5. Copy the web site generated to the 'gh-pages' branch. e.g."
        println()
        println '   cd ../site-armeria'
        println '   rm -fr .[bd]* *'
        println '   rsync -aiP ../upstream-armeria/site/build/site/ .'
        println '   git add -A .'
        println "   git commit --amend -m 'Deploy the web site'"
        println '   git push --force'
    }
}

private def getGitPath() {
    if (rootProject.hasProperty('gitPath')) {
        return rootProject.property('gitPath')
    }

    // Find the location of the 'git' command.
    try {
        if (osdetector.os == 'windows') {
            return executeCommand('where.exe', 'git.exe')
        } else {
            return executeCommand('which', 'git')
        }
    } catch (e) {
        logger.debug('Git not available:', e)
        return null
    }
}

private def getRepoStatus() {
    // Make sure this method is executed only once during the build.
    assert !rootProject.hasProperty('repoStatus')

    // The default values taken from Netty.
    def result = [
            version : project.version,
            longCommitHash : '0000000000000000000000000000000000000000',
            shortCommitHash : '0000000',
            commitDate : '1970-01-01 00:00:00 +0000',
            repoStatus : 'unknown'
    ]

    // Make sure 'git' is available.
    if (gitPath == null) {
        return result
    }

    // Do not run 'git' if the project is not from a Git repository.
    if (!rootProject.file("${rootProject.projectDir}/.git").isDirectory()) {
        return result
    }

    // Retrieve the repository status from the Git repository.
    try {
        def gitLogOut = executeCommand(gitPath, 'log', '-1', '--format=format:%h%x20%H%x20%cd', '--date=iso')
        if (gitLogOut) {
            logger.info("Latest commit: ${gitLogOut}")
            def tokens = gitLogOut.tokenize(' ')
            result.shortCommitHash = tokens[0]
            result.longCommitHash = tokens[1]
            result.commitDate = tokens[2..4].join(' ')
        }

        def gitStatusOut = executeCommand(gitPath, 'status', '--porcelain')
        if (!gitStatusOut.empty) {
            result.repoStatus = 'dirty'
            logger.info("Repository is dirty:${System.lineSeparator()}${gitStatusOut}")
        } else {
            result.repoStatus = 'clean'
        }
    } catch (e) {
        logger.warn('Failed to retrieve the repository status:', e)
    }

    return result
}

private static String executeCommand(String[] command) {
    def proc = command.execute()
    proc.waitFor()
    if (proc.exitValue() != 0) {
        throw new IOException(
                "'${command}' exited with a non-zero exit code: ${proc.exitValue()}:" +
                "${System.lineSeparator()}${proc.err.text}")
    }

    return proc.in.text.trim()
}

// TODO(trustin): Remove this workaround once a newer version of shadow plugin is released.
// Work around the bug where ShadowJar does not set the character set of the output JAR correctly.
// See: https://github.com/johnrengelman/shadow/issues/283
class ShadowJar extends com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar {
    @Override
    protected ZipCompressor getInternalCompressor() {
        return new DefaultZipCompressor(false, ZipOutputStream.DEFLATED) {
            @Override
            ZipOutputStream createArchiveOutputStream(File destination) {
                ZipOutputStream zout = super.createArchiveOutputStream(destination)
                zout.setEncoding("UTF-8")
                return zout
            }
        }
    }
}
