import org.objectweb.asm.ClassReader
import org.objectweb.asm.ClassVisitor
import org.objectweb.asm.ClassWriter
import org.objectweb.asm.MethodVisitor
import org.objectweb.asm.Opcodes

import java.nio.file.Files
import java.nio.file.Paths

buildscript {
    repositories {
        mavenCentral()
    }

    dependencies {
        classpath 'com.google.gradle:osdetector-gradle-plugin:1.4.0'
        classpath 'org.ow2.asm:asm:5.1'
    }
}

apply plugin: 'com.google.osdetector'

dependencies {
    // Guava
    compile 'com.google.guava:guava'
    testCompile 'com.google.guava:guava-testlib'

    // Jackson
    [ 'jackson-core', 'jackson-annotations', 'jackson-databind' ].each {
        compile "com.fasterxml.jackson.core:$it"
    }

    // Metrics
    compile 'io.dropwizard.metrics:metrics-core'

    // Netty
    [ 'netty-transport', 'netty-codec-http2', 'netty-resolver-dns' ].each {
        compile "io.netty:$it"
    }
    compile "io.netty:netty-transport-native-epoll:${versionOf('netty')}:linux-x86_64"
    compile 'io.netty:netty-tcnative-boringssl-static'
    runtime 'org.javassist:javassist'

    // Reactive Streams
    compile 'org.reactivestreams:reactive-streams'

    // Reflections
    compile 'org.reflections:reflections'

    // Thrift
    compile 'org.apache.thrift:libthrift'

    // gRPC (optional)
    [ 'grpc-core', 'grpc-stub', 'grpc-protobuf' ].each {
        compile("io.grpc:$it") {
            ext.optional = true
        }
    }
    testCompile 'io.grpc:grpc-interop-testing'

    // Jetty (optional)
    compile('org.eclipse.jetty:jetty-server') {
        ext.optional = true
    }
    [ 'jetty-webapp', 'jetty-annotations', 'apache-jsp', 'apache-jstl' ].each {
        testCompile "org.eclipse.jetty:$it"
    }
    testCompile 'org.eclipse.jetty.http2:http2-server'

    // Tomcat (optional)
    [ 'tomcat-embed-core', 'tomcat-embed-jasper', 'tomcat-embed-el' ].each {
        compile("org.apache.tomcat.embed:$it") {
            ext.optional = true
        }
    }
    compile('org.slf4j:log4j-over-slf4j') {
        ext.optional = true
    }

    // Zipkin (optional)
    [ 'brave-core', 'brave-http' ].each {
        compile("io.zipkin.brave:$it") {
            ext.optional = true
        }
    }
}

clean {
    // Delete the source files generated by the Thrift compiler.
    doLast {
        [ 'main', 'test' ].each {
            project.delete("${project.projectDir}/src/$it/gen-java")
        }
    }
}

// Compile the Thrift IDL with the correct binary.
task compileThrift {
    def thriftPath = "$project.projectDir/src/build/thrift.${osdetector.classifier}"

    [ 'main', 'test' ].each { scope ->
        def inputDir = "${project.projectDir}/src/${scope}/thrift"
        def outputDir = "${project.projectDir}/src/${scope}/gen-java"

        inputs.dir inputDir
        outputs.dir outputDir

        project.sourceSets[scope].java.srcDir outputDir

        project.fileTree(inputDir) {
            include '**/*.thrift'
        }.each { sourceFile ->
            doLast {
                project.mkdir(outputDir)
                project.exec {
                    commandLine thriftPath,
                            '-gen', 'java',
                            '-out', outputDir,
                            '-I', "${sourceFile.parentFile.absolutePath}",
                            sourceFile.absolutePath
                }
            }
        }
    }
}

// Ensure the generated source files are available during compilation.
tasks.compileJava.dependsOn(compileThrift)
// Ensure the generated source files are available when imported by an IDE.
afterEvaluate { tasks.compileThrift.execute() }

// Remove the methods that did not exist until Tomcat 8.5 from the ProtocolHandler implementation using
// bytecode manipulation. We need the methods to exist during compilation time since we compile the
// ProtocolHandler implementation against Tomcat 8.5, but want to make sure the methods do not exist because
// otherwise JVM will fail to load the ProtocolHandler due to the references to the non-existent classes in the
// method signatures.
compileJava << {
    def path = Paths.get("${project.buildDir}", 'classes', 'main',
                         'com', 'linecorp', 'armeria', 'server', 'http', 'tomcat',
                         'Tomcat80ProtocolHandler.class')

    logger.info("Manipulating ${path} ..")

    def reader = new ClassReader(Files.readAllBytes(path))
    def writer = new ClassWriter(ClassWriter.COMPUTE_MAXS)

    reader.accept(new ClassVisitor(Opcodes.ASM5, writer) {
        @Override
        MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {
            if (name == 'addSslHostConfig' || name == 'findSslHostConfigs' ||
                name == 'addUpgradeProtocol' || name == 'findUpgradeProtocols') {
                return null
            } else {
                return super.visitMethod(access, name, desc, signature, exceptions)
            }
        }
    }, 0)

    Files.write(path, writer.toByteArray())
}

// Ensure that test resources are copied to the class output directory so that TomcatService.forClassPath()
// works in TomcatServiceTest.
processTestResources {
    destinationDir = project.file("${project.buildDir}/classes/test")
}
