---
menuTitle: "Implement DELETE"
order: 6
type: step
tags:
  - rest
  - request
  - request-converter
  - exceptions
  - exception-handling
  - blocking
level: basic
---

# Implementing DELETE operation

In this step, we'll write a method for deleting a blog post. The HTTP method we map with this method is DELETE.

<TutorialSteps current={6} />

By completing this step, you'll learn to map your service with the HTTP DELETE (<type://@Delete>) method, customize an exception handler, and use a blocking task executor.

## What you need

You need to have these files prepared from previous steps.

- [BlogService.java](/tutorials/tutorial-blog-rest-step3#0-create-a-service-file)
- [BlogPost.java](/tutorials/tutorial-blog-rest-step2)

## 1. Map HTTP method

Let's start with [mapping the HTTP DELETE method](/docs/server-annotated-service#mapping-http-service-methods) with our service method:

1. [Create a service file](/tutorials/tutorial-blog-rest-step3#0-create-a-service-file) if you're yet to create one.
2. Declare a service method, `deleteBlogPost()` in the class `BlogService`.
3. Map this service method with the HTTP DELETE method by adding the <type://@Delete> annotation.
4. Assign the endpoint as `/blogs`.

```java filename=BlogService.java highlight=1
@Delete("/blogs")
public HttpResponse deleteBlogPost(int id) {
  // Implementation
}
```

## 2. Handle parameters

Let's take the blog post ID (`id`) as a path parameter for identifying the post to delete.

1. Take in the ID value as a path parameter by adding `/blogs/:id` to the <type://@Delete> annotation.
2. [Inject the path parameter](/docs/server-annotated-service#parameter-injection) to the service method by annotating the parameter with <type://@Param>.
  ```java filename=BlogService.java
  @Delete("/blogs/:id")
  public HttpResponse deleteBlogPost(@Param int id) {
    // Implementation
  }
  ```

## 3. Implement service code

In this step, write the code to delete a blog post, handle an exception, and block the operation.

- [Delete a blog post](#delete-a-blog-post)
- [Handle exceptions](#handle-exceptions)
- [Add blocking](#add-blocking)

### Delete a blog post

Deleting a given blog post in this tutorial means removing a blog post from the map, `blogPosts`. However, in real services you would be performing this action on a database.

To delete a blog post, copy the code below to the `deleteBlogPost()` method.

```java filename=BlogService.Java highlight=2
public HttpResponse deleteBlogPost(@Param int id) {
  BlogPost removed = blogPosts.remove(id);
  ...
```

### Handle exceptions

What if there is no such post to delete? We can check if the blog exists before attempting to remove the blog post, but here, let's handle it after the attempt.

1. Throw an `IllegalArgumentException` when no blog post exists with a given ID.
  ```java filename=BlogService.java
  if (removed == null) {
    throw new IllegalArgumentException("The blog post does not exist. id: " + id);
  }
  ```
2. Create an exception handler for the blog service:
  1. Create a file, BadRequestExceptionHandler.java
  2. In the file, declare a custom exception handler implementing Armeria's <type://ExceptionHandlerFunction> interface.
  ```java filename=BadRequestExceptionHandler.java
  public class BadRequestExceptionHandler implements ExceptionHandlerFunction {
    private static final ObjectMapper mapper = new ObjectMapper();
    ...
  }
  ```
3. Implement your own exception handler by overriding the default `handleException()` method. Add a code block for handling the `IllegalArgumentException` thrown. For this tutorial, return a BAD REQUEST as the response.
  ```java filename=BadRequesExceptionHandler.java highlight=3,9,10,12,14
  @Override
  public HttpResponse handleException(ServiceRequestContext ctx, HttpRequest req, Throwable cause) {
    if (cause instanceof IllegalArgumentException) {
        String message = cause.getMessage();
        ObjectNode objectNode = mapper.createObjectNode();
        objectNode.put("error", message);
        try {
            return HttpResponse.of(HttpStatus.BAD_REQUEST,
                                    MediaType.JSON_UTF_8, mapper.writeValueAsString(objectNode));
        } catch (JsonProcessingException e) {
            return HttpResponse.of(HttpStatus.BAD_REQUEST);
        }
    }
    return ExceptionHandlerFunction.fallthrough();
  }
  ```
4. Assign the exception handler to the `deleteBlogPost()` method by annotating the `deletePost()` method with the <type://@ExceptionHandler> as follows.
  ```java filename=BlogService.java highlight=1
  @Delete("/blogs/:id")
  @ExceptionHandler(BadRequestExceptionHandler.class)
  public HttpResponse deleteBlogPost(@Param int id) {
    ...
  ```

### Add blocking

With real services, accessing and operating on a database takes time. To prevent the service to wait on our task, we want to inform the task executor to handle other tasks until we're done with database operation.

To enable this, we use Armeria's [blocking task executor](/docs/server-annotated-service#specifying-a-blocking-task-executor). There are a few options of implementing this; we'll annotate our service method with the <type://@Blocking>.

```java filename=BlogService.java highlight=1
@Blocking
@Delete("/blogs/:id")
@ExceptionHandler(BadRequestExceptionHandler.class)
public HttpResponse deleteBlogPost(@Param int id) {
```

## 4. Return response

We've already handled returning the not found error in the [exception handling section](#handle-exception). Here, we'll return a response for successful deletion.

```java filename=BlogService.java
public HttpResponse deleteBlogPost(@Param int id) {
  ...
  return HttpResponse.of(HttpStatus.NO_CONTENT);
}
```

## Next step

In this step, you've written a method for a DELETE operation and used Armeria's annotations; <type://@Delete>, <type://@Param>, <type://@ExceptionHandler> and <type://@Blocking>.

Next, at [Step 7. Add services to server](/tutorials/tutorial-blog-rest-step7), let's go back to the main method and add the blog service to our server.

<TutorialSteps current={6} />
