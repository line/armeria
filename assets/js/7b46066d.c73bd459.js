"use strict";(globalThis.webpackChunkarmeria_site=globalThis.webpackChunkarmeria_site||[]).push([[3566],{28453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>s});var t=r(96540);const i={},l=t.createContext(i);function o(e){const n=t.useContext(l);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(l.Provider,{value:n},e.children)}},64697:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"client/grpc","title":"Calling a gRPC service","description":"Visit armeria-examples to find a fully working example.","source":"@site/src/content/docs/client/grpc.mdx","sourceDirName":"client","slug":"/client/grpc","permalink":"/docs/client/grpc","draft":false,"unlisted":false,"editUrl":"https://github.com/line/armeria/edit/main/site/src/content/docs/client/grpc.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Calling a Thrift service","permalink":"/docs/client/thrift"},"next":{"title":"Customizing a ClientFactory with ClientFactoryBuilder","permalink":"/docs/client/factory"}}');var i=r(74848),l=r(28453);const o={},s="Calling a gRPC service",a={},c=[{value:"Exception propagation",id:"exception-propagation",level:2},{value:"See also",id:"see-also",level:2}];function u(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,l.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"calling-a-grpc-service",children:"Calling a gRPC service"})}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["Visit ",(0,i.jsx)(n.a,{href:"https://github.com/line/armeria-examples",children:"armeria-examples"})," to find a fully working example."]})}),"\n",(0,i.jsxs)(n.p,{children:["Let's assume we have the following ",(0,i.jsx)(n.a,{href:"https://grpc.io/",children:"gRPC"})," service definition, served at ",(0,i.jsx)(n.code,{children:"http://127.0.0.1:8080/"}),", just like\nwhat we used in ",(0,i.jsx)(n.a,{href:"/docs/server/grpc",children:"Running a gRPC service"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-protobuf",children:'syntax = "proto3";\n\npackage grpc.hello;\n\noption java_package = "com.example.grpc.hello";\n\nservice HelloService {\n  rpc Hello (HelloRequest) returns (HelloReply) {}\n}\n\nmessage HelloRequest {\n  string name = 1;\n}\n\nmessage HelloReply {\n  string message = 1;\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Making a call starts from creating a client:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'import com.linecorp.armeria.client.grpc.GrpcClients;\n\nHelloServiceBlockingStub helloService = GrpcClients.newClient(\n        "gproto+http://127.0.0.1:8080/",\n        HelloServiceBlockingStub.class); // or HelloServiceFutureStub.class or HelloServiceStub.class\n\nHelloRequest request = HelloRequest.newBuilder().setName("Armerian World").build();\nHelloReply reply = helloService.hello(request);\nassert reply.getMessage().equals("Hello, Armerian World!");\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Note that we added the serialization format of the call using the ",(0,i.jsx)(n.code,{children:"+"})," operator in the scheme part of the URI.\nBecause we are calling a ",(0,i.jsx)(n.a,{href:"https://grpc.io/",children:"gRPC"})," server, we can choose: ",(0,i.jsx)(n.code,{children:"gproto"})," or ",(0,i.jsx)(n.code,{children:"gjson"}),". If you are using ",(0,i.jsx)(n.a,{href:"https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md",children:"gRPC-Web"}),",\nyou can use ",(0,i.jsx)(n.code,{children:"gproto-web"}),", ",(0,i.jsx)(n.code,{children:"gproto-web-text"})," or ",(0,i.jsx)(n.code,{children:"gjson-web"}),"."]}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["If a serialization format is not specified, ",(0,i.jsx)(n.code,{children:"gproto"})," will be used by default."]})}),"\n",(0,i.jsxs)(n.p,{children:["Since we specified ",(0,i.jsx)(n.code,{children:"HelloServiceBlockingStub.class"})," as the client type, ",(0,i.jsx)(n.code,{children:"Clients.newClient()"})," will return a\nsynchronous client implementation. If we specified ",(0,i.jsx)(n.code,{children:"HelloServiceFutureStub"}),", the calling code would have\nlooked like the following:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'import com.google.common.util.concurrent.Futures;\nimport com.google.common.util.concurrent.ListenableFuture;\nimport com.google.common.util.concurrent.MoreExecutors;\nimport com.linecorp.armeria.client.grpc.GrpcClients;\nimport java.util.concurrent.ForkJoinPool;\n\nHelloServiceFutureStub helloService = GrpcClients.newClient(\n        "gproto+http://127.0.0.1:8080/",\n        HelloServiceFutureStub.class);\n\nHelloRequest request = HelloRequest.newBuilder().setName("Armerian World").build();\nListenableFuture<HelloReply> future = helloService.hello(request);\n\nFutures.addCallback(future, new FutureCallback<HelloReply>() {\n    @Override\n    public void onSuccess(HelloReply result) {\n        assert result.getMessage().equals("Hello, Armerian World!");\n    }\n\n    @Override\n    public void onFailure(Throwable t) {\n        t.printStackTrace();\n    }\n}, MoreExecutors.directExecutor());\n\n// You can also wait until the call is finished.\nHelloReply reply = future.get();\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The asynchronous stub uses Guava's ",(0,i.jsx)(n.a,{href:"https://google.github.io/guava/releases/21.0/api/docs/com/google/common/util/concurrent/ListenableFuture.html",children:"ListenableFuture"})," and can be operated on using methods on ",(0,i.jsx)(n.a,{href:"https://google.github.io/guava/releases/21.0/api/docs/com/google/common/util/concurrent/Futures.html",children:"Futures"}),". The\n",(0,i.jsx)(n.a,{href:"https://github.com/spotify/futures-extra",children:"futures-extra"})," library is very convenient for working with ",(0,i.jsx)(n.a,{href:"https://google.github.io/guava/releases/21.0/api/docs/com/google/common/util/concurrent/ListenableFuture.html",children:"ListenableFuture"})," in Java 8, including the ability\nto convert it to ",(0,i.jsx)(n.a,{href:"https://docs.oracle.com/javase/10/docs/api/java/util/concurrent/CompletableFuture.html",children:"CompletableFuture"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://grpc.io/",children:"gRPC"})," also natively supports streaming RPC. If our service definition included this method:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-protobuf",children:"service HelloService {\n  rpc ManyHellos (stream HelloRequest) returns (stream HelloReply) {}\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"You can also use the builder pattern for client construction:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'import com.linecorp.armeria.common.HttpRequest;\nimport com.linecorp.armeria.common.HttpResponse;\nimport com.linecorp.armeria.common.grpc.GrpcSerializationFormats;\n\nHelloServiceBlockingStub helloService =\n    GrpcClients.builder("http://127.0.0.1:8080/")\n           .serializationFormat(GrpcSerializationFormats.PROTO)\n           .responseTimeoutMillis(10000)\n           .decorator(LoggingClient.newDecorator())\n           .build(HelloServiceBlockingStub.class); // or HelloServiceFutureStub.class\n                                                   // or HelloServiceStub.class\n\nHelloRequest request = HelloRequest.newBuilder().setName("Armerian World").build();\nHelloReply reply = helloService.hello(request);\nassert reply.getMessage().equals("Hello, Armerian World!");\n'})}),"\n",(0,i.jsxs)(n.p,{children:["As you might have noticed already, we decorated the client using ",(0,i.jsx)(n.a,{href:"type://https://javadoc.io/doc/com.linecorp.armeria/armeria-javadoc/latest/com/linecorp/armeria/client/logging/LoggingClient.html",children:"LoggingClient"}),", which logs all\nrequests and responses. You might be interested in decorating a client using other decorators, for example\nto gather metrics. Please also refer to ",(0,i.jsx)(n.a,{href:"type://https://javadoc.io/doc/com.linecorp.armeria/armeria-javadoc/latest/com/linecorp/armeria/client/ClientBuilder.html",children:"ClientBuilder"})," for more configuration options."]}),"\n",(0,i.jsx)(n.h2,{id:"exception-propagation",children:"Exception propagation"}),"\n",(0,i.jsxs)(n.p,{children:["If you have enabled ",(0,i.jsx)(n.code,{children:"Flags.verboseResponses()"})," in the server being accessed by specifying\n",(0,i.jsx)(n.code,{children:"-Dcom.linecorp.armeria.verboseResponses=true"})," system property, then any exception during processing\nin the server will be returned to the client as a ",(0,i.jsx)(n.a,{href:"type://https://javadoc.io/doc/com.linecorp.armeria/armeria-javadoc/latest/com/linecorp/armeria/common/grpc/StatusCauseException.html",children:"StatusCauseException"})," attached to the normal gRPC\n",(0,i.jsx)(n.code,{children:"Status"}),". This can be used for programmatic access to the exception that happened in the server. In this\nexample, the server always fails with ",(0,i.jsx)(n.code,{children:'throw new IllegalStateException("Failed!");'})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'import com.linecorp.armeria.client.grpc.GrpcClients;\nimport com.linecorp.armeria.common.grpc.StatusCauseException;\n\nimport io.grpc.StatusRuntimeException;\n\nHelloServiceBlockingStub helloService = GrpcClients.newClient(\n        "gproto+http://127.0.0.1:8080/",\n        HelloServiceBlockingStub.class); // or HelloServiceFutureStub.class or HelloServiceStub.class\n\nHelloRequest request = HelloRequest.newBuilder().setName("Armerian World").build();\ntry {\n    HelloReply reply = helloService.hello(request);\n} catch (StatusRuntimeException e) {\n    if (e.getCause() instanceof StatusCauseException) {\n        StatusCauseException cause = (StatusCauseException) e.getCause();\n        // The name of the class of the exception and its message in the server can be accessed.\n        assert cause.getOriginalClassName().equals("java.lang.IllegalStateException");\n        assert cause.getOriginalMessage().equals("Failed!");\n\n        // The exception\'s message is a combination of both the class name and original message.\n        assert cause.getMessage().equals("java.lang.IllegalStateException: Failed!");\n\n        // The exception\'s stack trace is that which occurred when the server threw the exception.\n        cause.printStackTrace();\n\n        // Logging frameworks, as used by e.g., LoggingClient, will print the stack trace if configured\n        // to do so.\n\n        // Now you know exactly where to look in the server to figure out what may have gone wrong.\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"see-also",children:"See also"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/server/grpc",children:"Running a gRPC service"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/client/decorator",children:"Decorating a client"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/client/custom-http-headers",children:"Sending custom HTTP headers"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/advanced/kotlin#calling-a-grpc-kotlin-service",children:"Calling a gRPC kotlin service"})}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}}}]);