# Running a GraphQL service

<Tip>

Visit [armeria-examples](https://github.com/line/armeria-examples) to find a fully working example.

</Tip>

Let's assume we have the following [GraphQL Schema](https://graphql.org/learn/schema/):

```graphql
type Query {
  user(id: ID): User
}

type User {
  id: ID
  name: String
}
```

The schema describes that if a client requests a `User` data using the `ID` field, the GraphQL server will
return the `User` data. The GraphQL engine uses a [DataFetcher](https://javadoc.io/doc/com.graphql-java/graphql-java/latest/graphql/schema/DataFetcher.html)
to resolve the ID and fetch the corresponding object. For the sake of simplicity, let's implement
`UserDataFetcher` that stores `User`s in a `Map`:

```java
import graphql.schema.DataFetcher;
import graphql.schema.DataFetchingEnvironment;

class UserDataFetcher implements DataFetcher<User> {

    private final Map<String, User> data = Map.of("1", new User("1", "hero"),
                                                  "2", new User("2", "human"),
                                                  "3", new User("3", "droid"));

    @Override
    public User get(DataFetchingEnvironment environment) throws Exception {
        final String id = environment.getArgument("id");
        return data.get(id);
    }
}
```

<Tip>

Please note that this is entirely based on [graphql-java](https://www.graphql-java.com/).

</Tip>

## `GraphqlService`

Once you've finished the implementation of the [DataFetcher](https://javadoc.io/doc/com.graphql-java/graphql-java/latest/graphql/schema/DataFetcher.html), you need to build a <type://GraphqlService> using
a <type://GraphqlServiceBuilder> and add it to the <type://ServerBuilder>:

```java
import com.linecorp.armeria.server.Server;
import com.linecorp.armeria.server.ServerBuilder;

ServerBuilder sb = Server.builder();
...
sb.service("/graphql",
           GraphqlService.builder()
                         .runtimeWiring(c -> {
                            c.type("Query",
                                   typeWiring -> typeWiring.dataFetcher("user", new UserDataFetcher()));
                         })
                         .build());
...
Server server = sb.build();
server.start();
```

Here [RuntimeWiring](https://javadoc.io/doc/com.graphql-java/graphql-java/latest/graphql/schema/idl/RuntimeWiring.html) is a specification of [DataFetcher](https://javadoc.io/doc/com.graphql-java/graphql-java/latest/graphql/schema/DataFetcher.html)s, [TypeResolver](https://javadoc.io/doc/com.graphql-java/graphql-java/latest/graphql/schema/TypeResolver.html)s, and custom [scalar](https://javadoc.io/doc/com.graphql-java/graphql-java/latest/graphql/schema/GraphQLScalarType.html)s that are needed to wire together a functional [GraphQLSchema](https://javadoc.io/doc/com.graphql-java/graphql-java/latest/graphql/schema/GraphQLSchema.html).

## Blocking service implementation

Armeria does not run service logic in a separate thread pool by default. If your service implementation
requires blocking, either run the individual blocking logic in a thread pool, set
<type://GraphqlServiceBuilder#useBlockingTaskExecutor(boolean)> so the above happens automatically for
all service methods and lifecycle callbacks.

```java
ServerBuilder sb = Server.builder();
sb.service("/graphql",
           GraphqlService.builder()
                         .runtimeWiring(c -> {
                            c.type("Query",
                                   typeWiring -> typeWiring.dataFetcher("user", new UserDataFetcher()));
                         })
                         // All service methods will be run within
                         // the blocking executor.
                         .useBlockingTaskExecutor(true)
                         .build());
```

<Tip>

Another way is to wrap the [DataFetcher](https://javadoc.io/doc/com.graphql-java/graphql-java/latest/graphql/schema/DataFetcher.html) in an [AsyncDataFetcher](https://javadoc.io/doc/com.graphql-java/graphql-java/latest/graphql/schema/AsyncDataFetcher.html).

</Tip>
