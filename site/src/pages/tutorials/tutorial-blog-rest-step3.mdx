---
menuTitle: "Implement CREATE"
order: 3
type: step
tags:
  - rest
  - request
  - request-converter
level: basic
---

# Implementing CREATE operation

Now that we've prepared minimal files for the tutorial in [step 2](./tutorial-blog-rest-step2), it's time to start writing the core of the service.

<TutorialSteps current={3} />

In this step, we create a file to contain our service methods. The first service method we write is for creating a blog post. The HTTP method to map with is POST.

By completing this step, you learn how to map your service with HTTP POST (<type://@Post>) and make your own request converter (<type://@RequestConverter>).

## What you need

You need the BlogPost.java file, created from [step 2](./tutorial-blog-rest-step2). You can always [download](https://github.com/line/armeria-examples/blob/master/rest-api-annotated-service/src/main/java/example/armeria/server/blog/BlogPost.java) the full version of this file, instead of creating one yourself.

## 0. Create a service file

1. Create a service file, BlogService.java.
2. Declare a class, `BlogService`, in the file. Import required files as you go along the tutorial or copy all from the [sample file](https://github.com/line/armeria-examples/blob/master/rest-api-annotated-service/src/main/java/example/armeria/server/blog/BlogService.java).
  ```java filename=BlogService.java
  public final class BlogService {

    private static final ObjectMapper mapper = new ObjectMapper();

    private final Map<Integer, BlogPost> blogPosts = new ConcurrentHashMap<>();
    ...
  ```

## 1. Map HTTP method

Start by [mapping HTTP POST method](/docs/server-annotated-service#mapping-http-service-methods) with our service method, which we will declare at this step:

1. Declare a service method, `createBlogPost()`, in the class `BlogService`.
2. [Map this service method](/docs/server-annotated-service#mapping-http-service-methods) with the HTTP POST by adding the <type://@Post> annotations.
3. Assign the endpoint as `/blogs`.

```java filename=BlogService.java highlight=1
@Post("/blogs")
public HttpResponse createBlogPost(BlogPost blogPost) throws JsonProcessingException {}
```

## 2. Handle parameters

Let's take post information through a request body. Armeria's [request converter](/docs/server-annotated-service#converting-an-http-request-to-a-java-object) converts request parameters in HTTP messages into Java objects for you. In the request converter we define what keys of a JSON object to map with what properties of a Java object.

To handle parameters received for creating a blog post, use <type://RequestConvert>, in these steps. The order may be changed.

- [Write a request converter](#write-a-request-converter)
- [Assign a request converter](#assign-a-request-converter)

### Write a request converter

Armeria's [request converter](../docs/server-annotated-service#converting-an-http-request-to-a-java-object) converts a request body from a client into a Java object for you.

We can use Armeria's default request converter as is, but here let's give a go at customizing a request converter for our blog post requests. We want to convert blog post details into a Java object.

1. Create a BlogPostRequestConverter.java file and declare a class, implementing the <type://RequestConverterFunction> interface. For simplicity sake, generate impromptu IDs for this tutorial.
  ```java filename=BlogRequestConverter.java
  final class BlogPostRequestConverter implements RequestConverterFunction {
    private static final ObjectMapper mapper = new ObjectMapper();
    private final AtomicInteger idGenerator = new AtomicInteger(); // Blog post ID
  }
  ```
2. Add a method retrieving a value of a given key in a JSON object:
  ```java filename=BlogRequestConverter.java highlight="4"
    static String stringValue(JsonNode jsonNode, String field) {
      final JsonNode value = jsonNode.get(field);
      if (value == null) {
          throw new IllegalArgumentException(field + " is missing!");
      }
      return value.textValue();
    }
  ```
3. Customize the default `convertRequest()` method as follows.
    ```java filename=BlogRequestConverter.java
    @Override
    public Object convertRequest(ServiceRequestContext ctx,
      AggregatedHttpRequest request, Class<?> expectedResultType,
      @Nullable ParameterizedType expectedParameterizedResultType)
        throws Exception {
      if (expectedResultType == BlogPost.class) {
        final JsonNode jsonNode = mapper.readTree(request.contentUtf8());
        final int id = idGenerator.getAndIncrement();
        final String title = stringValue(jsonNode, "title");
        final String content = stringValue(jsonNode, "content");
        return new BlogPost(id, title, content); // Create an instance of BlogPost object
      }
      return RequestConverterFunction.fallthrough();
    }
  ```

### Assign a request converter

In this step, assign the [request converter we customized](#write-a-request-converter) to our service method. Annotate the service method with <type://@RequestConverter> and specify the <type://RequestConverterFunction> class as `BlogPostRequestConverter.class`.

```java filename=BlogService.java highlight=2
@Post("/blogs")
@RequestConverter(BlogPostRequestConverter.class)
public HttpResponse createBlogPost(BlogPost blogPost) throws JsonProcessingException {
  // Implement blog service
}
```

## 3. Implement service code

When the request for creation is received, our request converter creates an instance of a blog post object for us. We want to save the blog post object in the map (`blogPosts`) created in the `BlogService` class.

To store the blog post information in the map, add the code (line 4) in the `createBlogPost()` method.

```java filename=BlogService.java highlight=4
@Post("/blogs")
@RequestConverter(BlogPostRequestConverter.class)
public HttpResponse createBlogPost(BlogPost blogPost) throws JsonProcessingException {
  blogPosts.put(blogPost.id(), blogPost);
}
```

## 4. Return response

Now, it's time to return a response to our client. As the response, on top of the information received, add the ID of the post, created time, plus modified time which would be identical to the created time.

1. Specify JSON object keys for each member of our blog post object, by annotating the following methods with `@JsonProperty`.
  ```java filename=BlogPost.java highlight=3,6,9,12,15
  final class BlogPost {
    ...
    @JsonProperty("id")
    int id() { return id; }

    @JsonProperty("title")
    String title() { return title; }

    @JsonProperty("content")
    String content() { return content; }

    @JsonProperty("createdAt")
    long createdAt() { return createdAt; }

    @JsonProperty("modifiedAt")
    long modifiedAt() { return modifiedAt; }
    ...
  }
  ```
2. Create and return an HTTP response using Armeria's <type://HttpResponse> and include the information of the post created in the `createBlogPost()` method.
  ```java filename=BlogService.java
  public HttpResponse createBlogPost(BlogPost blogPost) throws JsonProcessingException {
    ...
    return HttpResponse.of(HttpStatus.OK, MediaType.JSON_UTF_8, mapper.writeValueAsBytes(blogPost));
  }
  ```

## Next step

In this step, you've written a method to implement a CREATE operation and used Armeria's annotations; <type://@Post> and <type://@RequestConverter>.

Next, at [Step 4. Implement READ](./tutorial-blog-rest-step4), you will implement a READ operation to read a single post and multiple posts.

<TutorialSteps current={3} />