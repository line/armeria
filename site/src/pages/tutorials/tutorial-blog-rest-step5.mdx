---
menuTitle: "Implement UPDATE"
order: 5
type: step
tags:
  - rest
  - request
  - requestobject
level: basic
---

# Implementing UPDATE operation

We've implemented [CREATE](/tutorials/tutorial-blog-rest-step3) and [READ](/tutorials/tutorial-blog-rest-step4) operations.

In this step, we'll write a method for updating a blog post. The HTTP method we map with this method is GET.

<TutorialSteps current={5} />

By completing this step, you'll learn to map your service with the HTTP PUT (<type://@Put>) method, use parameter injection, and convert request body into a Java object using a request object (<type://@RequestObject>).

## What you need

You need to have these files prepared from previous steps.

- [BlogService.java](/tutorials/tutorial-blog-rest-step3#0-create-a-service-file)
- [BlogPost.java](/tutorials/tutorial-blog-rest-step2)

## 1. Map HTTP method

Let's start with [mapping the HTTP PUT method](/docs/server-annotated-service#mapping-http-service-methods) with our service method:

1. [Create a service file](/tutorials/tutorial-blog-rest-step3#0-create-a-service-file) if you're yet to create one.
2. Declare a service method, `updateBlogPost()`, in the class `BlogService`.
3. Map this service method with the HTTP PUT method by adding the <type://@Put> annotation.
4. Assign the endpoint as `/blogs`.

```java filename=BlogService.java highlight=1
@Put("/blogs")
public HttpResponse updateBlogPost(int id, BlogPost blogPost)
        throws JsonProcessingException {
  // Update a blog post
}
```

## 2. Handle parameters

For updating a blog post, let's take a blog post ID (`id`) and new blog post information to update with. For [creating a blog post](/tutorials/tutorial-blog-rest-step3), we've used Armeria's <type://RequestConverter> to convert a request body into a Java object. For a change, let's try using <type://@RequestObject> to convert a request body.

1. Take in the ID value as a path parameter by adding `/blogs/:id` to the <type://@Put> annotation.
2. [Inject the path parameter](/docs/server-annotated-service#parameter-injection) to the service method by annotating the parameter with <type://@Param>.
3. [Convert request body](/docs/server-annotated-service#converting-an-http-request-to-a-java-object) into a Java object by annotating the `BlogPost` parameter with <type://@RequestObject>.
  ```java filename=BlogService.java
  // Instructions 1 to 3
  @Put("/blogs/:id")
  public HttpResponse updateBlogPost(@Param int id, @RequestObject BlogPost blogPost)
    throws JsonProcessingException {
      // Update a blog post
  }
  ```
4. For conversion, annotate blog post constructor to map JSON object keys to blog post object members. You can find more information on `@JsonCreator` [here](https://www.baeldung.com/jackson-annotations#1-jsoncreator).
  ```java filename=BlogPost.java
  @JsonCreator
  BlogPost(@JsonProperty("id") int id, @JsonProperty("title") String title,
            @JsonProperty("content") String content) {
      ...
  }
  ```

## 3. Implement service code

In this step, write the code required for service itself. You need to update the information contained in the `blogPosts` map. In real services, you'll be retrieving and updating the blog post information from and to a database.

To update a blog post, copy the following code inside the `updateBlogPost()` method.

```java filename=BlogService.java
  public HttpResponse updateBlogPost(@Param int id, @RequestObject BlogPost blogPost){
    final BlogPost oldBlogPost = blogPosts.get(id);
    // Check if the given blog post exists
    if (oldBlogPost == null) {
        // Return a Not Found error. See the next section for instructions
    }
    final BlogPost newBlogPost = new BlogPost(id, blogPost.title(),
        blogPost.content(),
        oldBlogPost.createdAt(),
        blogPost.createdAt()
    );
    blogPosts.put(id, newBlogPost); // Update the info in the map
    ...
  }
```

## 4. Return response

Two possibilities are available for the response. If the blog post to update exists, we respond to the client that the update has been successful. The other response is informing the client that the blog post doesn't exist.

### Return error

Let's return an error for the request to update a blog post that doesn't exist.

Inside the condition block of the `getBlogPost()` method added in the previous step, return a response using Armeria's <type://HTTPResponse>, with the content of the response as `HttpStatus.NOT_FOUND`.

```java filename=BlogService.java highlight=4
public HttpResponse updateBlogPost(@Param int id, @RequestObject BlogPost blogPost){
  ...
  if (oldBlogPost == null) {
    return HttpResponse.of(HttpStatus.NOT_FOUND);
  }
  ...
```

### Return success

Let's return the information updated when the blog post exists. To return updated information, copy the code below to the `updateBlogPost()` method.

```java filename=BlogService.java
public HttpResponse updateBlogPost(@Param int id, @RequestObject BlogPost blogPost){
  ...
  final byte[] bytes = mapper.writeValueAsBytes(newBlogPost);
  return HttpResponse.of(HttpStatus.OK, MediaType.JSON_UTF_8, bytes);
}
```

## Next step

In this step, you've implemented a method for an UPDATE operation and used Armeria's annotations; <type://@Put>, <type://@Param>, and <type://@RequestObject>.

Next, at [Step 6. Implement DELETE](/tutorials/tutorial-blog-rest-step6), you'll implement a DELETE operation to delete blog posts.

<TutorialSteps current={5} />